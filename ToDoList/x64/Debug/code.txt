main.cpp:
#define UNICODE
#define _UNICODE

#include "Windows.h"
#include "ApplicationUI.h"
#include "AppState.h"
#include <commctrl.h>
#include "resource.h"
#include "AppConfig.h"

#pragma comment(lib, "comctl32.lib")

using namespace ApplicationUserInterface;

// Global variables
HINSTANCE hInst;
LPCTSTR szWindowClass = L"EventManager";
LPCTSTR szTitle = L"Event Manager";
HBRUSH hTransparentBrush = (HBRUSH)GetStockObject(NULL_BRUSH);

// Forward declarations
ATOM MyRegisterClass(HINSTANCE hInstance);
BOOL InitInstance(HINSTANCE, int);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

AppState* appState;

int APIENTRY wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nCmdShow)
{
	MSG msg;

	// Initialize common controls
	INITCOMMONCONTROLSEX icex;
	icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
	icex.dwICC = ICC_LISTVIEW_CLASSES | ICC_DATE_CLASSES | ICC_BAR_CLASSES;
	InitCommonControlsEx(&icex);

	// Register window class
	MyRegisterClass(hInstance);

	// Perform application initialization
	if (!InitInstance(hInstance, nCmdShow))
	{
		return FALSE;
	}

	HACCEL hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATORS));

	// Main message loop:
	while (GetMessage(&msg, NULL, 0, 0))
	{
		if (!TranslateAccelerator(ApplicationUI::hMainWnd, hAccel, &msg))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	return (int)msg.wParam;
}

ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;
	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = WndProc;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = hInstance;
	wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APP));
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = szWindowClass;
	wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_APP));

	return RegisterClassEx(&wcex);
}

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
	hInst = hInstance;

	// Create main window
	HWND hWnd = CreateWindow(
		szWindowClass,
		szTitle,
		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		800,
		600,
		NULL,
		NULL,
		hInstance,
		NULL
	);

	if (!hWnd)
	{
		return FALSE;
	}

	// Initialize application state and UI

	appState = new AppState();
	ApplicationUI::Initialize(hWnd, appState);

	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);

	return TRUE;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_CREATE:
        break;

    case WM_COMMAND:
        ApplicationUI::HandleCommand(hWnd, wParam, lParam);
        break;

    case WM_TIMER:
        ApplicationUI::HandleTimer(hWnd, wParam, lParam);
        break;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);
        EndPaint(hWnd, &ps);
    }
    break;

	case WM_CTLCOLORSTATIC:
	{
		HDC hdcStatic = (HDC)wParam;
		HWND hwndStatic = (HWND)lParam;

		// Make all static controls transparent
		SetBkMode(hdcStatic, TRANSPARENT);

		int ctrlId = GetDlgCtrlID(hwndStatic);
		switch (ctrlId)
		{
		default:
			SetTextColor(hdcStatic, RGB(0, 0, 0)); // Black text
		}

		return (LRESULT)hTransparentBrush;
	}

    case WM_DESTROY:
        appState->Cleanup();
        delete appState;
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

AppState.cpp:

#include "AppState.h"
#include "Event.h"
#include <shlobj.h>
#include <stdio.h>
#include <string.h>
#include <commctrl.h>
#include "Utilities.h"
#include <sstream>
#include "ApplicationUI.h"

#pragma region Initialization & Cleanup

AppState::AppState()
{
	currentEventsCount = 0;
	filteredEventsCapacity = 0;
	SetAutoUpdateEnabled(true);
	SetAutoUpdateIntervalSec(DEFAULT_AUTO_UPDATE_INTERVAL_SEC);
	ResizeEventArrays(4);

	// Initialize last metrics update to current time
	GetLocalTime(&lastMetricsUpdate);

	// Load categories from config file or use default
	if (!AppConfig::LoadConfig() || (AppConfig::GetCategoryCount() == 0))
	{
		for (int i = 0; i < DEFAULT_CATEGORY_COUNT; ++i)
		{
			AppConfig::AddCategory(DEFAULT_CATEGORIES[i]);
		}
	}

	if (!LoadEvents(defaultEventsSavePath))
	{
		// If loading failed, create empty events file
		try
		{
			// Create empty file
			FILE* file = NULL;
			if (_wfopen_s(&file, defaultEventsSavePath.c_str(), L"w,ccs=UTF-8") == 0 && file)
			{
				fclose(file);
				currentEventsCount = 0;
				currentSavePath = defaultEventsSavePath;
			}
			else
			{
				MessageBoxW(NULL,
					L"Не вдалося створити файл подій",
					L"Помилка",
					MB_ICONERROR);
			}
		}
		catch (...)
		{
			MessageBoxW(NULL,
				L"Помилка при створенні файлу подій",
				L"Помилка",
				MB_ICONERROR);
		}
	}

	UpdateEvents();
}

void AppState::Cleanup()
{
	AppConfig::SaveConfig();
	currentEventsCount = 0;
	savedEventsCount = 0;
	delete[] currentEvents;
	delete[] savedEvents;

	if (filteredEvents != nullptr)
	{
		delete[] filteredEvents;
		filteredEvents = nullptr;
	}
	filteredEventsCount = 0;
	filteredEventsCapacity = 0;
}

#pragma endregion


#pragma region Event Management

void AppState::SetAutoUpdateEnabled(bool isEnabled)
{
	autoUpdateEnabled = isEnabled;

	if (!autoUpdateEnabled)
	{
		SetAutoUpdateIntervalSec(DEFAULT_AUTO_UPDATE_INTERVAL_SEC);
	}
}

void AppState::SetAutoUpdateIntervalSec(int updateIntervalSec)
{
	if (updateIntervalSec > 0.1f)
	{
		autoUpdateInterval = updateIntervalSec;
	}
}

int AppState::GetAutoUpdateIntervalSec()
{
	return autoUpdateInterval;
}

bool AppState::IsAutoUpdateEnabled()
{
	return autoUpdateEnabled;
}

Event* AppState::GetAllEvents()
{
	return currentEvents;
}

int AppState::GetAllEventsCount()
{
	return currentEventsCount;
}

bool AppState::AddEvent(Event* event)
{
	if (currentEventsCount >= eventsCapacity)
	{
		if (!ResizeEventArrays(eventsCapacity * 2))
		{
			return false;
		}
	}

	currentEvents[currentEventsCount] = *event;
	currentEventsCount++;
	UpdateEvents();
	return true;
}

// Method to search an event by GUID
Event* AppState::FindEventByGUID(const GUID& eventGUID)
{
	for (int i = 0; i < currentEventsCount; ++i)
	{
		if (IsEqualGUID(currentEvents[i].uniqueID, eventGUID))
		{
			return &currentEvents[i];  // Return the pointer to the found event
		}
	}
	return nullptr;  // Return nullptr if event was not found
}

bool AppState::ToggleEventCompletion(const Event* event)
{
	Event* targetEvent = FindEventByGUID(event->uniqueID);

	if (targetEvent != nullptr && !targetEvent->isPastDeadline)
	{
		targetEvent->isCompleted = !targetEvent->isCompleted;
		return true;
	}
	return false;
}


bool AppState::DeleteEvent(const Event* event)
{
	// Find the event by GUID
	Event* targetEvent = FindEventByGUID(event->uniqueID);
	if (targetEvent == nullptr)
		return false;  // Event not found

	// Find the index of the event in currentEvents array
	int index = -1;
	for (int i = 0; i < currentEventsCount; ++i)
	{
		if (IsEqualGUID(currentEvents[i].uniqueID, event->uniqueID))
		{
			index = i;
			break;
		}
	}

	if (index == -1)
		return true;

	// Shift all elements after the found index one position left
	for (int i = index; i < currentEventsCount - 1; i++)
	{
		currentEvents[i] = currentEvents[i + 1];
	}

	currentEventsCount--;
	UpdateEvents();

	return true;
}


Event* AppState::GetEvent(int index)
{
	return &currentEvents[index];
}

bool AppState::ResizeEventArrays(int newCapacity)
{
	Event* newCurrent = new Event[newCapacity];
	Event* newSaved = new Event[newCapacity];

	if (!newCurrent || !newSaved)
	{
		delete[] newCurrent;
		delete[] newSaved;
		return false;
	}

	// Copy existing events
	for (int i = 0; i < currentEventsCount; i++)
	{
		newCurrent[i] = currentEvents[i];
	}

	for (int i = 0; i < savedEventsCount; i++)
	{
		newSaved[i] = savedEvents[i];
	}

	// Clean up old arrays
	delete[] currentEvents;
	delete[] savedEvents;

	// Assign new arrays
	currentEvents = newCurrent;
	savedEvents = newSaved;
	eventsCapacity = newCapacity;

	return true;
}

bool AppState::SaveChanges()
{
	// Ensure saved array has enough capacity
	if (savedEventsCount < currentEventsCount)
	{
		if (!ResizeEventArrays(max(eventsCapacity, currentEventsCount)))
		{
			return false;
		}
	}

	// Copy all current events to saved
	savedEventsCount = currentEventsCount;
	for (int i = 0; i < currentEventsCount; i++)
	{
		savedEvents[i] = currentEvents[i];
	}

	return true;
}

bool AppState::DiscardChanges()
{
	// Ensure current array has enough capacity
	if (currentEventsCount < savedEventsCount)
	{
		if (!ResizeEventArrays(max(eventsCapacity, savedEventsCount)))
		{
			return false;
		}
	}

	// Copy all saved events to current
	currentEventsCount = savedEventsCount;
	for (int i = 0; i < savedEventsCount; i++)
	{
		currentEvents[i] = savedEvents[i];
	}

	UpdateEvents();
	return true;
}

void AppState::UpdateEvents()
{
	SYSTEMTIME now;
	GetLocalTime(&now);

	// count how many new recurring events we'll need to create
	int newRecurringCount = 0;
	for (int i = 0; i < currentEventsCount; i++)
	{
		Event* event = &currentEvents[i];
		event->UpdateStatus();

		if (event->isRecurring && event->isPastDeadline &&
			!event->isCompleted && !event->isReccurenceHandled)
		{
			Event newEvent = *event;

			switch (event->recurrenceInterval)
			{
			case RecurrenceInterval::Daily:
				newEvent.deadline.wDay++;
				break;
			case RecurrenceInterval::Weekly:
				newEvent.deadline.wDay += 7;
				break;
			case RecurrenceInterval::Monthly:
				newEvent.deadline.wMonth++;
				break;
			case RecurrenceInterval::Yearly:
				newEvent.deadline.wYear++;
				break;
			case RecurrenceInterval::Custom:
				newEvent.deadline.wDay += event->customRecurrenceDays;
				break;
			default:
				break;
			}

			// Normalize the date
			NormalizeSystemTime(&newEvent.deadline);

			newEvent.isCompleted = false;
			newEvent.isPastDeadline = false;
			newEvent.isReccurenceHandled = false;
			CoCreateGuid(&newEvent.uniqueID);

			// Mark original as handled
			event->isReccurenceHandled = true;

			AddEvent(&newEvent);
		}
	}

	if (newRecurringCount == 0)
		return;

	Event* newEvents = new Event[currentEventsCount + newRecurringCount];
	int newEventsCount = 0;

	for (int i = 0; i < currentEventsCount; i++)
	{
		// Copy the original event
		newEvents[newEventsCount++] = currentEvents[i];
		Event* currentEvent = &newEvents[newEventsCount - 1];

		// Handle recurrence if needed
		if (currentEvent->isRecurring && currentEvent->isPastDeadline &&
			!currentEvent->isCompleted && !currentEvent->isReccurenceHandled)
		{
			Event newEvent = *currentEvent;

			
		}
	}

	// Replace old array with new one
	delete[] currentEvents;
	currentEvents = newEvents;
	currentEventsCount = newEventsCount;
	eventsCapacity = currentEventsCount;

	// Update filtered events if needed
	if (hasFilters)
	{
		ApplyCurrentFilter();
	}
}

void AppState::ClearPastEvents()
{
	int writeIndex = 0;
	for (int i = 0; i < currentEventsCount; i++)
	{
		if (!(currentEvents[i].isPastDeadline && !currentEvents[i].isCompleted))
		{
			currentEvents[writeIndex] = currentEvents[i];
			writeIndex++;
		}
	}
	currentEventsCount = writeIndex;
}

// Comparison functions for each sorting type
bool CompareByDeadline(const Event& a, const Event& b)
{
	return CompareSystemTimes(a.deadline, b.deadline) < 0;
}

bool CompareByPriority(const Event& a, const Event& b)
{
	return a.priority > b.priority; // Higher priority first
}

bool CompareByName(const Event& a, const Event& b)
{
	return a.name < b.name;
}

bool CompareByCreationDate(const Event& a, const Event& b)
{
	return CompareSystemTimes(a.creationDate, b.creationDate) < 0;
}

void AppState::SortEvents(SortType sortType)
{
	// Determine which array to sort and its size
	bool hasFilters = HasFilters();
	Event* arrayToSort = hasFilters ? filteredEvents : currentEvents;
	int count = hasFilters ? filteredEventsCount : currentEventsCount;

	if (count <= 1) return;

	// Sort the appropriate array using the comparison function
	switch (sortType)
	{
	case SortType::Deadline:
		std::sort(arrayToSort, arrayToSort + count, CompareByDeadline);
		break;
	case SortType::Priority:
		std::sort(arrayToSort, arrayToSort + count, CompareByPriority);
		break;
	case SortType::Name:
		std::sort(arrayToSort, arrayToSort + count, CompareByName);
		break;
	case SortType::CreationDate:
		std::sort(arrayToSort, arrayToSort + count, CompareByCreationDate);
		break;
	default:
		break;
	}
}

bool AppState::SaveEvents()
{
	if (!currentSavePath.empty())
	{
		return SaveEventsAs(currentSavePath);
	}
	return false;
}

bool AppState::SaveEventsAs(const std::wstring& filePath)
{
	FILE* file = NULL;
	errno_t err = _wfopen_s(&file, filePath.c_str(), L"w,ccs=UTF-8");
	if (err != 0 || !file)
	{
		MessageBoxW(NULL, L"Не вдалося створити файл для збереження", L"Помилка збереження", MB_ICONERROR);
		return false;
	}

	try
	{
		for (int i = 0; i < currentEventsCount; i++)
		{
			Event* event = &currentEvents[i];

			// Write event header
			if (fwprintf(file, L"[Event %d]\n", i + 1) < 0)
				throw std::runtime_error("Не вдалося записати заголовок події");

			// Write basic fields with error checking
			if (fwprintf(file, L"Name=%s\n", event->name.c_str()) < 0 ||
				fwprintf(file, L"Description=%s\n", event->description.c_str()) < 0 ||
				fwprintf(file, L"Notes=%s\n", event->notes.c_str()) < 0 ||
				fwprintf(file, L"Category=%s\n", event->category.c_str()) < 0)
			{
				throw std::runtime_error("Не вдалося записати текстові поля");
			}

			// Write boolean fields
			if (fwprintf(file, L"Completed=%s\n", event->isCompleted ? L"true" : L"false") < 0 ||
				fwprintf(file, L"PastDeadline=%s\n", event->isPastDeadline ? L"true" : L"false") < 0 ||
				fwprintf(file, L"Recurring=%s\n", event->isRecurring ? L"true" : L"false") < 0)
			{
				throw std::runtime_error("Не вдалося записати булеві поля");
			}

			// Write numeric fields
			if (fwprintf(file, L"Priority=%d\n", event->priority) < 0 ||
				fwprintf(file, L"RecurrenceInterval=%d\n", static_cast<int>(event->recurrenceInterval)) < 0 ||
				fwprintf(file, L"CustomRecurrenceDays=%d\n", event->customRecurrenceDays) < 0)
			{
				throw std::runtime_error("Не вдалося записати числові поля");
			}

			// Write dates with proper formatting
			if (fwprintf(file, L"CreationDate=%04d-%02d-%02d %02d:%02d\n",
				event->creationDate.wYear, event->creationDate.wMonth, event->creationDate.wDay,
				event->creationDate.wHour, event->creationDate.wMinute) < 0 ||
				fwprintf(file, L"Deadline=%04d-%02d-%02d %02d:%02d\n",
					event->deadline.wYear, event->deadline.wMonth, event->deadline.wDay,
					event->deadline.wHour, event->deadline.wMinute) < 0)
			{
				throw std::runtime_error("Не вдалося записати дати");
			}

			// Add separator
			if (fwprintf(file, L"\n") < 0)
				throw std::runtime_error("Не вдалось записати розділювач");
		}

		currentSavePath = filePath;
	}
	catch (const std::exception& e)
	{
		std::wstring prefix = L"Помилка під час зберігання подій у файл";
		std::wstring errorMsg = GetTranslatedErrorMessage(e);
		std::wstring fullMessage = prefix + errorMsg;

		MessageBoxW(NULL, fullMessage.c_str(), L"Помилка зберігання", MB_ICONERROR);
		if (file)
		{
			fclose(file);
			// Delete incomplete file
			_wremove(filePath.c_str());
		}
		return false;
	}

	SaveChanges();
	fclose(file);
	return true;
}

bool AppState::LoadEvents(const std::wstring& filePath)
{
	// Open file and read raw bytes
	FILE* file = NULL;
	if (_wfopen_s(&file, filePath.c_str(), L"rb") != 0 || !file)
	{
		return false;
	}

	// Get file size
	fseek(file, 0, SEEK_END);
	long fileSize = ftell(file);
	fseek(file, 0, SEEK_SET);

	if (fileSize <= 0)
	{
		fclose(file);
		return false;
	}

	// Read the file into a buffer
	char* buffer = new char[fileSize];
	if (fread(buffer, 1, fileSize, file) != static_cast<size_t>(fileSize))
	{
		delete[] buffer;
		fclose(file);
		return false;
	}
	fclose(file);

	// Remove BOM if present (UTF-8 or UTF-16 BOM)
	std::wstring content;
	int encoding = IS_TEXT_UNICODE_UNICODE_MASK;
	size_t offset = 0;

	if (IsTextUnicode(reinterpret_cast<BYTE*>(buffer), fileSize, &encoding))
	{
		// UTF-16 file, no need for conversion
		if (fileSize > 2 && (buffer[0] == (char)0xFF && buffer[1] == (char)0xFE))  // UTF-16 BOM check
		{
			offset = 2; // Skip BOM
		}
		content.assign(reinterpret_cast<wchar_t*>(buffer + offset), (fileSize - offset) / sizeof(wchar_t));
	}
	else
	{
		// Handle UTF-8 and ANSI encodings
		content = ConvertToWideStringFromUtf8OrAnsi(buffer, fileSize);
	}

	// Clean up buffer
	delete[] buffer;

	// Remove BOM from content
	if (!content.empty() && (content[0] == L'\xFEFF' || content[0] == L'\xFFFE'))
	{
		content.erase(0, 1);  // Remove BOM
	}

	// Clear existing events
	currentEventsCount = 0;
	Event* currentEvent = nullptr;

	std::wistringstream iss(content);
	std::wstring line;

	while (std::getline(iss, line))
	{
		// Trim whitespace
		TrimString(line);

		if (line.empty()) continue;

		// New event section
		if (line[0] == L'[' && line.find(L"Event") != std::wstring::npos)
		{
			if (currentEventsCount >= MAX_EVENTS)
			{
				MessageBoxW(NULL, L"Максимальна кількість подій досягнута", L"Попередження", MB_ICONWARNING);
				break;
			}

			if (currentEventsCount >= eventsCapacity)
			{
				ResizeEventArrays(eventsCapacity * 2);
			}
			currentEvent = &currentEvents[currentEventsCount++];
			*currentEvent = Event(); // Reset to defaults
			continue;
		}

		if (!currentEvent) continue;

		// Parse key-value pair
		size_t eqPos = line.find(L'=');
		if (eqPos == std::wstring::npos) continue;

		std::wstring key = line.substr(0, eqPos);
		std::wstring value = line.substr(eqPos + 1);

		// Trim whitespace
		TrimString(key);
		TrimString(value);

		try
		{
			ParseEventData(key, value, currentEvent);

			if (key == L"Category")
			{
				if (AppConfig::AddCategory(currentEvent->category.c_str()))
				{
					ApplicationUserInterface::ApplicationUI::RefreshCategories();
					AppConfig::SaveConfig();
				}
			}
		}
		catch (const std::exception& e)  // Catch standard exceptions
		{
			// Display the exception message
			std::wstring errorPrefix = L"Помилка завантаження з файлу: ";
			std::wstring errorMessage = GetTranslatedErrorMessage(e);
			std::wstring fullMessage = errorPrefix + errorMessage;

			MessageBoxW(NULL, fullMessage.c_str(), L"Помилка завантаження", MB_ICONERROR);
			currentEventsCount = 0;
			return false;
		}
		catch (...)
		{
			// Catch any non-standard exception
			MessageBoxW(NULL, L"Помилка завантаження з файлу : неможливо виконати парсинг даних. Можливо файл пошкоджено.", L"Помилка завантаження", MB_ICONERROR);
			currentEventsCount = 0;
			return false;
		}
	}

	currentSavePath = filePath;
	SaveChanges();
	return true;
}

void AppState::ParseEventData(const std::wstring& key, const std::wstring& value, Event* currentEvent)
{
	if (key == L"Name")
	{
		if (value.length() > MAX_EVENT_NAME_LENGTH)
			throw std::runtime_error("Назва події перевищує максимальну довжину");
		currentEvent->name = value;
	}
	else if (key == L"Description")
	{
		if (value.length() > MAX_EVENT_DESC_LENGTH)
			throw std::runtime_error("Опис перевищує максимальну довжину");
		currentEvent->description = value;
	}
	else if (key == L"Notes")
	{
		if (value.length() > MAX_EVENT_NOTES_LENGTH)
			throw std::runtime_error("Примітки перевищують максимальну довжину");
		currentEvent->notes = value;
	}
	else if (key == L"Category")
	{
		if (value.length() > MAX_EVENT_CATEGORY_LENGTH)
			throw std::runtime_error("Категорія перевищує максимальну довжину");
		currentEvent->category = value;
	}
	else if (key == L"Completed")
	{
		currentEvent->isCompleted = (value == L"true");
	}
	else if (key == L"PastDeadline")
	{
		currentEvent->isPastDeadline = (value == L"true");
	}
	else if (key == L"Recurring")
	{
		currentEvent->isRecurring = (value == L"true");
	}
	else if (key == L"Priority")
	{
		int priority = _wtoi(value.c_str());
		if (priority < 0 || priority > 3) // Assuming priority range is 0-3
			throw std::runtime_error("Невірне значення пріоритету");
		currentEvent->priority = static_cast<EventPriority>(priority);
	}
	else if (key == L"RecurrenceInterval")
	{
		int interval = _wtoi(value.c_str());
		if (interval < 0 || interval > 4) // Assuming 0-4 for None, Daily, Weekly, Monthly, Yearly, Custom
			throw std::runtime_error("Невірне значення інтервалу повторення");
		currentEvent->recurrenceInterval = static_cast<RecurrenceInterval>(interval);
	}
	else if (key == L"CustomRecurrenceDays")
	{
		int days = _wtoi(value.c_str());
		if (days < 0 || days > 365 * 10) // Reasonable limit for custom days
			throw std::runtime_error("Невірне значення кількості днів для інтервалу повторення");
		currentEvent->customRecurrenceDays = days;
	}
	else if (key == L"CreationDate" || key == L"Deadline")
	{
		SYSTEMTIME* st = (key == L"CreationDate") ? &currentEvent->creationDate : &currentEvent->deadline;
		if (swscanf_s(value.c_str(), L"%04d-%02d-%02d %02d:%02d",
			&st->wYear, &st->wMonth, &st->wDay, &st->wHour, &st->wMinute) != 5)
		{
			throw std::runtime_error("Невірний формат дати");
		}

		// Additional date validation
		if (st->wYear < 1900 || st->wYear > 2100 ||
			st->wMonth < 1 || st->wMonth > 12 ||
			st->wDay < 1 || st->wDay > 31 ||
			st->wHour > 23 || st->wMinute > 59)
		{
			throw std::runtime_error("Невірні значення дати");
		}
	}
	else
	{
		throw std::runtime_error("Невідоме поле в даних події");
	}
}


#pragma endregion


#pragma region Filters

bool AppState::ResizeFilteredEventsArray(int newCapacity)
{
	if (newCapacity <= filteredEventsCapacity)
		return true;

	// Allocate a new array with the required capacity
	Event* newArray = new Event[newCapacity]; // A simple 1D array of Event
	if (!newArray)
		return false;

	// Copy the events from the old array to the new one
	for (int i = 0; i < filteredEventsCount; i++)
	{
		newArray[i] = filteredEvents[i];
	}

	// Delete the old array
	delete[] filteredEvents;
	filteredEvents = newArray;
	filteredEventsCapacity = newCapacity;
	return true;
}

// Get the filtered events (or all events if no filter is applied)
Event* AppState::GetFilteredEvents()
{
	return hasFilters ? filteredEvents : currentEvents;
}

// Get the number of filtered events (or total events if no filter is applied)
int AppState::GetFilteredEventsCount() const
{
	return hasFilters ? filteredEventsCount : currentEventsCount;
}

// Check if filtered results are being shown
bool AppState::HasFilters() const
{
	return hasFilters;
}

// Reset the filter and clear the search text
void AppState::ResetFilter()
{
	hasFilters = false;
	currentFilter = All;
	currentSearchText.clear();
	filteredEventsCount = 0;
}

// Apply the current filter and update the filtered events list
void AppState::FilterEvents(FilterType filterType)
{
	currentFilter = filterType;
	ApplyCurrentFilter();
}

// Search events based on the search text
void AppState::SearchEvents(const std::wstring& searchText)
{
	currentSearchText = searchText;
	ApplyCurrentFilter();
}

void AppState::FilterByCategory(const std::wstring& category)
{
	currentCategoryFilter = category;
	ApplyCurrentFilter();
}

// Apply the current filter and update the filtered events
void AppState::ApplyCurrentFilter()
{
	filteredEventsCount = 0;
	hasFilters = false;

	// Ensure we have enough capacity in the filtered events array
	if (filteredEventsCapacity < currentEventsCount)
	{
		if (!ResizeFilteredEventsArray(currentEventsCount + 10))
			return;
	}

	// Apply the filter based on the filter type
	for (int i = 0; i < currentEventsCount; i++)
	{
		Event* event = &currentEvents[i];
		bool matchesFilter = true;

		// Apply status filter
		switch (currentFilter)
		{
		case Active: matchesFilter &= !event->isCompleted && !event->isPastDeadline; break;
		case Completed: matchesFilter &= event->isCompleted; break;
		case PastDue: matchesFilter &= event->isPastDeadline && !event->isCompleted; break;
		case All: break;
		}

		// Apply search text filter
		if (!currentSearchText.empty())
		{
			matchesFilter &= (event->name.find(currentSearchText) != std::wstring::npos) ||
				(event->description.find(currentSearchText) != std::wstring::npos);
		}

		// Apply category filter
		if (!currentCategoryFilter.empty())
		{
			matchesFilter &= (event->category == currentCategoryFilter);
		}

		if (matchesFilter)
		{
			filteredEvents[filteredEventsCount++] = *event;
		}
	}

	// If filtered events exist, or there is a non-empty search text, or filter is not 'All', show filtered results

	hasFilters = (currentFilter != All) || (!currentSearchText.empty()) || (!currentCategoryFilter.empty());
}

#pragma endregion

AppState.h:

#pragma once
#include <windows.h>
#include <commctrl.h>
#include "Event.h"
#include "AppConfig.h"
#include "Utilities.h"

class AppState
{
public:
    enum SortType
    {
        Name,
        Priority,
        Deadline,
        CreationDate,
    };

        enum FilterType
    {
        All,
        Active,
        Completed,
        PastDue
    };

    // Methods
    AppState();
    void Cleanup();

    bool AddEvent(Event* event);
    bool DeleteEvent(const Event* event);
    bool ToggleEventCompletion(const Event* event);
    Event* GetEvent(int index);
    void UpdateEvents();
    void ClearPastEvents();
    void SortEvents(SortType sortType);
    Event* GetAllEvents();
    int GetAllEventsCount();

    // Auto update settings
    void SetAutoUpdateEnabled(bool isEnabled);
    void SetAutoUpdateIntervalSec(int updateIntervalSec);
    int GetAutoUpdateIntervalSec();
    bool IsAutoUpdateEnabled();

    // Get filtered/search results
    void SearchEvents(const std::wstring& searchText);
    void FilterEvents(FilterType filterType);
    void FilterByCategory(const std::wstring& category);
    Event* GetFilteredEvents();
    int GetFilteredEventsCount() const;
    bool HasFilters() const;
    void ResetFilter();
    void ApplyCurrentFilter();
    Event* FindEventByGUID(const GUID& eventGUID);

    bool LoadEvents(const std::wstring& filePath);
    bool SaveEvents();
    bool SaveEventsAs(const std::wstring& filePath);

    bool SaveChanges();
    bool DiscardChanges();

private:

    // Event data
    Event* currentEvents = nullptr;
    Event* savedEvents = nullptr;

    int currentEventsCount = 0;
    int savedEventsCount = 0;
    int eventsCapacity = 0;

    // Filtered events
    Event* filteredEvents = nullptr;
    int filteredEventsCount = 0;
    int filteredEventsCapacity = 0;
    bool hasFilters = false;
    FilterType currentFilter = All;
    std::wstring currentSearchText;
    std::wstring currentCategoryFilter;

    // Settings
    bool autoUpdateEnabled;
    int autoUpdateInterval; // in minutes
    std::wstring currentSavePath;

    // Set default save path
    const std::wstring defaultEventsSavePath = GetExecutableFolderPath() + L"\\events.txt";

    // Metrics
    SYSTEMTIME lastMetricsUpdate;

    void ParseEventData(const std::wstring& key, const std::wstring& value, Event* currentEvent);
    bool ResizeEventArrays(int newCapacity);
    bool ResizeFilteredEventsArray(int newCapacity);
};

ApplicationUI.cpp:

#define UNICODE
#define _UNICODE

#include "ApplicationUI.h"
#include "EventDialog.h"
#include <windowsx.h>
#include <string>
#include <algorithm>
#include "Utilities.h"
#include "resource.h"
#include "EventList.h"
#include "CategoryComboBox.h"

#pragma comment(lib, "comctl32.lib")
#pragma comment(lib, "uxtheme.lib")

namespace ApplicationUserInterface
{
	AppState* ApplicationUI::appState = nullptr;

	// Main window handle
	HWND ApplicationUI::hMainWnd;

	// UI controls
	HWND hEditSearch;
	HWND hComboFilter;
	HWND hBtnUpdateNow;
	HWND hBtnClearPast;
	HWND hCheckRecurring;
	HWND hComboInterval;
	HWND hComboCategory;
	HWND hAutoUpdateCheck;
	HWND hAutoUpdateInterval;

	void ApplicationUI::Initialize(HWND hWnd, AppState* appState)
	{
		ApplicationUI::appState = appState;
		hMainWnd = hWnd;

		// Initialize common controls
		INITCOMMONCONTROLSEX icex;
		icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
		icex.dwICC = ICC_LISTVIEW_CLASSES | ICC_DATE_CLASSES | ICC_BAR_CLASSES;
		InitCommonControlsEx(&icex);

		// Create all UI controls
		CreateMainWindowControls(hWnd);

		// Set up timers
		SetTimer(hWnd, ID_TIMER_UPDATE, appState->GetAutoUpdateIntervalSec() * 1000, NULL);

		// Initial UI update
		EventList::Initialize(&hWnd);
		UpdateUI();
	}

	void ApplicationUI::CreateMainWindowControls(HWND hWnd)
	{
		CreateMainWindowMenus(hWnd);

		// Register custom event list class
		WNDCLASS wc = { 0 };
		wc.lpfnWndProc = EventList::EventListWndProc;
		wc.hInstance = GetModuleHandle(NULL);
		wc.hCursor = LoadCursor(NULL, IDC_ARROW);
		wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
		wc.lpszClassName = L"CustomEventList";
		if (!RegisterClass(&wc))
		{
			MessageBox(NULL, L"Window Registration Failed!", L"Error!", MB_ICONEXCLAMATION | MB_OK);
			return;
		}

		CreateMainButtons(hWnd);
		CreateEventsSearch(hWnd);
		CreateFiltersComboBox(hWnd);
		CreateSortingComboBox(hWnd);
		CreateCategoryComboBox(hWnd);
		CreateAutoUpdateControls(hWnd);
	}

	void ApplicationUI::CreateMainButtons(HWND& hWnd)
	{
		int buttonHorizontalSpacing = 35;
		int buttonVerticalSpacing = 40;
		int currentButton = -1;

		// Create buttons with larger sizes and better spacing
		CreateWindowW(L"BUTTON", L"Створити", WS_CHILD | WS_VISIBLE | WS_BORDER,
			10, 330 + buttonVerticalSpacing * (++currentButton), DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT, hWnd, (HMENU)ID_BUTTON_ADD, NULL, NULL);

		CreateWindowW(L"BUTTON", L"Редагувати", WS_CHILD | WS_VISIBLE | WS_BORDER,
			10, 330 + buttonVerticalSpacing * (++currentButton), DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT, hWnd, (HMENU)ID_BUTTON_EDIT, NULL, NULL);

		CreateWindowW(L"BUTTON", L"Видалити", WS_CHILD | WS_VISIBLE | WS_BORDER,
			10, 330 + buttonVerticalSpacing * (++currentButton), DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT, hWnd, (HMENU)ID_BUTTON_DELETE, NULL, NULL);

		CreateWindowW(L"BUTTON", L"Перемкнути виконання", WS_CHILD | WS_VISIBLE | WS_BORDER,
			10, 330 + buttonVerticalSpacing * (++currentButton), DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT, hWnd, (HMENU)ID_BUTTON_COMPLETE, NULL, NULL);

		currentButton = -1;

		hBtnClearPast = CreateWindowW(L"BUTTON", L"Очистити невиконані",
			WS_CHILD | WS_VISIBLE | WS_BORDER,
			DEFAULT_BUTTON_WIDTH + buttonHorizontalSpacing, 330 + buttonVerticalSpacing * (++currentButton), DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT, hWnd, (HMENU)ID_BUTTON_CLEAR, NULL, NULL);

		hBtnUpdateNow = CreateWindowW(L"BUTTON", L"Оновити список",
			WS_CHILD | WS_VISIBLE | WS_BORDER,
			DEFAULT_BUTTON_WIDTH + buttonHorizontalSpacing, 330 + buttonVerticalSpacing * (++currentButton), DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT, hWnd, (HMENU)ID_BUTTON_UPDATE, NULL, NULL);

		CreateWindowW(L"BUTTON", L"Статистика", WS_CHILD | WS_VISIBLE | WS_BORDER,
			605 - (DEFAULT_BUTTON_WIDTH + 10), 485, DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT, hWnd, (HMENU)ID_BUTTON_METRICS, NULL, NULL);

		CreateWindowW(L"BUTTON", L"Відмінити зміни", WS_CHILD | WS_VISIBLE | WS_BORDER,
			605, 485, DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT, hWnd, (HMENU)ID_BUTTON_DROP_CHANGES, NULL, NULL);
	}

	void ApplicationUI::CreateEventsSearch(HWND& hWnd)
	{
		CreateWindowW(L"STATIC", L"Пошук:", WS_CHILD | WS_VISIBLE | SS_RIGHT,
			500, 330, 60, 25, hWnd, NULL, NULL, NULL);

		hEditSearch = CreateWindowW(L"EDIT", L"",
			WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL,
			570, 330, 200, 25, hWnd, (HMENU)ID_EDIT_SEARCH, NULL, NULL);

		SendMessageW(hEditSearch, EM_LIMITTEXT, MAX_SEARCH_INPUT_LENGTH, 0);
	}

	void ApplicationUI::CreateFiltersComboBox(HWND& hWnd)
	{
		CreateWindowW(L"STATIC", L"Фільтрувати за:", WS_CHILD | WS_VISIBLE | SS_RIGHT,
			440, 370, 120, 25, hWnd, NULL, NULL, NULL);

		hComboFilter = CreateWindowW(L"COMBOBOX", L"",
			WS_CHILD | WS_VISIBLE | WS_BORDER | CBS_DROPDOWNLIST,
			570, 370, 200, 100, hWnd, (HMENU)ID_COMBO_FILTER, NULL, NULL);

		SendMessageW(hComboFilter, CB_ADDSTRING, 0, (LPARAM)L"Всі");
		SendMessageW(hComboFilter, CB_ADDSTRING, 0, (LPARAM)L"Активні");
		SendMessageW(hComboFilter, CB_ADDSTRING, 0, (LPARAM)L"Завершені");
		SendMessageW(hComboFilter, CB_ADDSTRING, 0, (LPARAM)L"Прострочені");
		SendMessageW(hComboFilter, CB_SETCURSEL, 0, 0);
	}

	void ApplicationUI::CreateSortingComboBox(HWND& hWnd)
	{
		CreateWindowW(L"STATIC", L"Сортувати за:", WS_CHILD | WS_VISIBLE | SS_RIGHT,
			440, 410, 120, 25, hWnd, NULL, NULL, NULL);

		HWND hComboSort = CreateWindowW(L"COMBOBOX", L"",
			WS_CHILD | WS_VISIBLE | WS_BORDER | CBS_DROPDOWNLIST | WS_VSCROLL,
			570, 410, 200, 100, hWnd, (HMENU)ID_COMBO_SORT, NULL, NULL);

		SendMessageW(hComboSort, CB_ADDSTRING, 0, (LPARAM)L"Без сортування");
		SendMessageW(hComboSort, CB_ADDSTRING, 0, (LPARAM)L"Назва");
		SendMessageW(hComboSort, CB_ADDSTRING, 0, (LPARAM)L"Пріоритет");
		SendMessageW(hComboSort, CB_ADDSTRING, 0, (LPARAM)L"Дедлайн");
		SendMessageW(hComboSort, CB_ADDSTRING, 0, (LPARAM)L"Дата створення");
		SendMessageW(hComboSort, CB_SETCURSEL, 0, 0);
	}

	void ApplicationUI::CreateCategoryComboBox(HWND& hWnd)
	{
		hComboCategory = CategoryComboBox::Create(
			hWnd,
			570,  // x
			450,  // y
			200,  // width
			30,   // height
			ID_COMBO_CATEGORY
		);
	}

	void ApplicationUI::RefreshCategories()
	{
		CategoryComboBox::UpdateCategories(hComboCategory);
	}

	void ApplicationUI::CreateAutoUpdateControls(HWND hWnd)
	{
		// Label
		CreateWindowW(L"STATIC", L"Авто-оновлення списку",
			WS_CHILD | WS_VISIBLE | SS_LEFT | SS_CENTERIMAGE,
			200, 415, 170, 25, hWnd, NULL, NULL, NULL);

		// Checkbox
		hAutoUpdateCheck = CreateWindowW(L"BUTTON", L"Увімкнути",
			WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX,
			200, 440, 100, 25, hWnd,
			(HMENU)ID_AUTO_UPDATE_CHECK, NULL, NULL);

		// Set initial state from AppState
		Button_SetCheck(hAutoUpdateCheck, appState->IsAutoUpdateEnabled() ? BST_CHECKED : BST_UNCHECKED);

		// Interval label
		CreateWindowW(L"STATIC", L"Інтервал (сек):",
			WS_CHILD | WS_VISIBLE | SS_LEFT,
			200, 470, 120, 25, hWnd, NULL, NULL, NULL);

		// Interval input
		hAutoUpdateInterval = CreateWindowW(L"EDIT", L"",
			WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER,
			310, 470, 60, 20, hWnd,
			(HMENU)ID_AUTO_UPDATE_INTERVAL, NULL, NULL);

		SendMessageW(hAutoUpdateInterval, EM_LIMITTEXT, 5, 0); // Max 5 characters


		// Set initial value and enable state
		std::wstring intervalText = std::to_wstring(appState->GetAutoUpdateIntervalSec());
		SetWindowTextW(hAutoUpdateInterval, intervalText.c_str());
		EnableWindow(hAutoUpdateInterval, appState->IsAutoUpdateEnabled());
	}

	void ApplicationUI::CreateMainWindowMenus(HWND hWnd)
	{
		// Create the menu bar
		HMENU hMenuBar = CreateMenu();
		HMENU hFileMenu = CreatePopupMenu();
		HMENU hHelpMenu = CreatePopupMenu();

		// File menu items with keyboard shortcuts
		AppendMenu(hFileMenu, MF_STRING, IDM_FILE_OPENAS, L"Відкрити як...\tCtrl+O");
		AppendMenu(hFileMenu, MF_STRING, IDM_FILE_SAVE, L"Зберегти\tCtrl+S");
		AppendMenu(hFileMenu, MF_STRING, IDM_FILE_SAVEAS, L"Зберегти як...\tCtrl+Shift+S");
		AppendMenu(hFileMenu, MF_SEPARATOR, 0, NULL);
		AppendMenu(hFileMenu, MF_STRING, IDM_FILE_EXIT, L"Вийти\tAlt+F4");

		// Help menu items with keyboard shortcut
		AppendMenu(hHelpMenu, MF_STRING, IDM_HELP_ABOUT, L"Інформація\tF1");

		// Add menus to menu bar
		AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hFileMenu, L"File");
		AppendMenu(hMenuBar, MF_POPUP, (UINT_PTR)hHelpMenu, L"Help");

		// Set the menu for the window
		SetMenu(hWnd, hMenuBar);
	}

#pragma region Handle Commands

	void ApplicationUI::HandleCommand(HWND hWnd, WPARAM wParam, LPARAM lParam)
	{
		HandleMainCommand(hWnd, wParam, lParam);
		HandleMenusCommand(hWnd, wParam, lParam);
	}

	void ApplicationUI::HandleMainCommand(HWND hWnd, WPARAM wParam, LPARAM lParam)
	{
		if (LOWORD(wParam) == ID_COMBO_CATEGORY && HIWORD(wParam) == CBN_SELCHANGE)
		{
			HandleCategoryFilter();
			return;
		}

		if (LOWORD(wParam) == ID_AUTO_UPDATE_INTERVAL && HIWORD(wParam) == EN_CHANGE)
		{
			HandleAutoUpdateIntervalInput();
			return;
		}

		switch (LOWORD(wParam))
		{
		case ID_BUTTON_ADD:
			AddNewEvent();
			break;
		case ID_BUTTON_EDIT:
			EditSelectedEvent();
			break;
		case ID_BUTTON_DELETE:
			DeleteSelectedEvent();
			break;
		case ID_BUTTON_COMPLETE:
			ToggleEventCompletion();
			break;
		case ID_BUTTON_UPDATE:
			UpdateEventsStatus();
			break;
		case ID_BUTTON_CLEAR:
			ClearPastEvents();
			break;
		case ID_BUTTON_METRICS:
			ShowMetrics();
			break;

		case ID_BUTTON_DROP_CHANGES:
			appState->DiscardChanges();
			RefilterEvents();
			UpdateUI();
			break;

		case ID_EDIT_SEARCH:
			if (HIWORD(wParam) == EN_CHANGE)
			{
				WCHAR searchText[256];
				GetWindowTextW(hEditSearch, searchText, 256);
				appState->SearchEvents(searchText);
				UpdateUI();
			}
			break;

		case ID_COMBO_FILTER:
			if (HIWORD(wParam) == CBN_SELCHANGE)
			{
				int selected = SendMessageW(hComboFilter, CB_GETCURSEL, 0, 0);
				appState->FilterEvents(static_cast<AppState::FilterType>(selected));
				UpdateUI();
			}
			break;
		case ID_COMBO_SORT:
			if (HIWORD(wParam) == CBN_SELCHANGE)
			{
				SortEvents();
				UpdateUI();
			}
			break;

		case ID_AUTO_UPDATE_CHECK:
			if (HIWORD(wParam) == BN_CLICKED)
			{
				BOOL enabled = Button_GetCheck(hAutoUpdateCheck) == BST_CHECKED;
				appState->SetAutoUpdateEnabled(enabled);
				EnableWindow(hAutoUpdateInterval, enabled);

				// Restart timer with new settings
				KillTimer(hWnd, ID_TIMER_UPDATE);
				if (enabled)
				{
					SetTimer(hWnd, ID_TIMER_UPDATE,
						appState->GetAutoUpdateIntervalSec() * 1000, NULL);
				}
			}
			break;

		case ID_AUTO_UPDATE_INTERVAL:
			if (HIWORD(wParam) == EN_CHANGE)
			{
				WCHAR text[32];
				GetWindowTextW(hAutoUpdateInterval, text, 32);
				int interval = _wtoi(text);
				if (interval > 0)
				{
					appState->SetAutoUpdateIntervalSec(interval);

					// Restart timer if auto-update is enabled
					if (appState->IsAutoUpdateEnabled())
					{
						KillTimer(hWnd, ID_TIMER_UPDATE);
						SetTimer(hWnd, ID_TIMER_UPDATE, interval * 1000, NULL);
					}
				}
			}
			break;
		}
	}

	void ApplicationUI::HandleAutoUpdateIntervalInput()
	{
		WCHAR buffer[16];
		GetWindowTextW(hAutoUpdateInterval, buffer, 16);

		int value = _wtoi(buffer);

		if (value > MAX_AUTO_UPDATE_INTERVAL_SEC)
		{
			std::wstring maxIntervalStr = std::to_wstring(MAX_AUTO_UPDATE_INTERVAL_SEC);

			// Clamp to max
			SetWindowTextW(hAutoUpdateInterval, maxIntervalStr.c_str());
		}
	}

	void ApplicationUI::HandleCategoryFilter()
	{
		int selectedIndex = SendMessageW(hComboCategory, CB_GETCURSEL, 0, 0);

		if (selectedIndex == 0)
		{
			// "All Categories" selected
			appState->FilterByCategory(L"");
		}
		else
		{
			// Get selected category text
			WCHAR categoryName[MAX_EVENT_CATEGORY_LENGTH] = L"\0";
			SendMessageW(hComboCategory, CB_GETLBTEXT, selectedIndex, (LPARAM)categoryName);
			appState->FilterByCategory(categoryName);
		}

		UpdateUI();
	}

	void ApplicationUI::HandleMenusCommand(HWND hWnd, WPARAM wParam, LPARAM lParam)
	{
		switch (LOWORD(wParam))
		{
			// Handle menu commands
		case IDM_FILE_OPENAS:
		{
			std::wstring filePath = GetOpenFilePath(hWnd);
			if (!filePath.empty())
			{
				appState->LoadEvents(filePath);
				UpdateUI();
			}
			break;
		}
		case IDM_FILE_SAVE:
			if (appState->SaveEvents())
			{
				MessageBoxW(NULL, L"Події успішно збережено у поточний файл!", L"Результат збереження", MB_ICONINFORMATION);
			}

			break;
		case IDM_FILE_SAVEAS:
		{
			std::wstring filePath = GetSaveFilePath(hWnd);
			if (!filePath.empty())
			{
				if (appState->SaveEventsAs(filePath))
				{
					MessageBoxW(NULL, L"Події успішно збережено!", L"Результат збереження", MB_ICONINFORMATION);
				}
			}
			break;
		}
		case IDM_FILE_EXIT:
			PostQuitMessage(0);
			break;
		
		case IDM_HELP_ABOUT:
			MessageBox(hWnd, AboutAppMessage.c_str(), L"Про додаток", MB_OK);
			break;
		}
	}

	void ApplicationUI::HandleTimer(HWND hWnd, WPARAM wParam, LPARAM lParam)
	{
		if (wParam == ID_TIMER_UPDATE && appState->IsAutoUpdateEnabled())
		{
			appState->UpdateEvents();
			HandleEventNotifications();
			UpdateUI();
		}
	}

	void ApplicationUI::HandleEventNotifications()
	{
		SYSTEMTIME now;
		GetLocalTime(&now);

		int count = appState->GetAllEventsCount();
		const Event* events = appState->GetAllEvents();

		for (int i = 0; i < count; i++)
		{
			const Event& event = events[i];
			Event& mutableEvent = const_cast<Event&>(event);

			if (event.isCompleted || event.isPastDeadline)
			{
				mutableEvent.ResetNotificationStates();
				continue;
			}

			// Check in order of priority
			if (IsDueWithin(event.deadline, 1) &&
				event.ShouldNotify(NOTIFICATION_1H))
			{
				ShowNotification(event, L"Залишилась 1 година до дедлайну події!");
				mutableEvent.MarkNotified(NOTIFICATION_1H);
				continue;
			}

			if (IsDueWithin(event.deadline, 12) &&
				event.ShouldNotify(NOTIFICATION_12H))
			{
				ShowNotification(event, L"Залишилось 12 годин до дедлайну події!");
				mutableEvent.MarkNotified(NOTIFICATION_12H);
				continue; 
			}

			if (IsDueWithin(event.deadline, 24) &&
				event.ShouldNotify(NOTIFICATION_24H))
			{
				ShowNotification(event, L"Залишилось 24 години до дедлайну події!");
				mutableEvent.MarkNotified(NOTIFICATION_24H);
			}
		}
	}

	void ApplicationUI::ShowNotification(const Event& event, const std::wstring& message)
	{
		NOTIFYICONDATA nid = { sizeof(nid) };
		nid.hWnd = hMainWnd;
		nid.uFlags = NIF_INFO;
		nid.dwInfoFlags = NIIF_USER | NIIF_LARGE_ICON;
		wcscpy_s(nid.szInfoTitle, (L"Нагадування про подію - " + event.name).c_str());
		wcscpy_s(nid.szInfo, message.c_str());

		nid.hIcon = LoadIcon(NULL, IDI_WARNING);

		Shell_NotifyIcon(NIM_ADD, &nid);
		Shell_NotifyIcon(NIM_DELETE, &nid);
	}

#pragma endregion


	void ApplicationUI::UpdateUI()
	{
		appState->HasFilters()
			? EventList::SetEventsList(appState->GetFilteredEvents(), appState->GetFilteredEventsCount())
			: EventList::SetEventsList(appState->GetAllEvents(), appState->GetAllEventsCount());

		EventList::Update();
	}

	void ApplicationUI::AddNewEvent()
	{
		Event newEvent;
		if (EventDialog::Show(hMainWnd, &newEvent))
		{
			appState->AddEvent(&newEvent);
			RefilterEvents();
			SendDlgItemMessage(hMainWnd, ID_COMBO_SORT, CB_SETCURSEL, 0, 0);
			UpdateUI();
		}
	}

	void ApplicationUI::EditSelectedEvent()
	{
		Event* originalEvent = nullptr;
		Event* eventToModify = nullptr;

		if (!EventList::TryGetSelectedEventFromList(originalEvent))
		{
			MessageBoxW(
				nullptr,
				L"Для редагування події, необхідно обрати її в списку!",
				L"Помилка редагування",
				MB_ICONERROR | MB_OK
			);

			return;
		}

		eventToModify = appState->FindEventByGUID(originalEvent->uniqueID);

		if (eventToModify == nullptr)
		{
			MessageBoxW(
				nullptr,
				L"Обраної події немає в основному списку, можливо дані були модифіковані, оновіть список.",
				L"Помилка редагування",
				MB_ICONERROR | MB_OK
			);

			return;
		}

		if (EventDialog::Show(hMainWnd, eventToModify, originalEvent))
		{
			appState->UpdateEvents();
			RefilterEvents();
			UpdateUI();
		}
	}

	void ApplicationUI::RefilterEvents()
	{
		if (appState->HasFilters())
		{
			appState->ApplyCurrentFilter();
		}
	}

	void ApplicationUI::DeleteSelectedEvent()
	{
		Event* selectedEvent = nullptr;

		if (!EventList::TryGetSelectedEventFromList(selectedEvent))
		{
			MessageBoxW(
				nullptr,
				L"Для видалення події, необхідно обрати її в списку!",
				L"Помилка видалення",
				MB_ICONERROR | MB_OK
			);

			return;
		}

		if (appState->DeleteEvent(selectedEvent))
		{
			RefilterEvents();
			UpdateUI();
		}
		else
		{
			MessageBoxW(
				nullptr,
				L"Не вдалося видалити подію. Спробуйте ще раз.",
				L"Помилка видалення",
				MB_ICONERROR | MB_OK
			);
		}
	}

	void ApplicationUI::ToggleEventCompletion()
	{
		Event* selectedEvent = nullptr;

		if (!EventList::TryGetSelectedEventFromList(selectedEvent))
		{
			MessageBoxW(
				nullptr,
				L"Для зміни статусу події, необхідно обрати її в списку!",
				L"Помилка",
				MB_ICONERROR | MB_OK
			);

			return;
		}

		if (appState->ToggleEventCompletion(selectedEvent))
		{
			RefilterEvents();
			UpdateUI();
		}
		else
		{
			MessageBoxW(
				nullptr,
				L"Не вдалося змінити статус завершення події. Можливо дедлайн був прострочений.",
				L"Помилка",
				MB_ICONERROR | MB_OK
			);
		}
	}

	void ApplicationUI::UpdateEventsStatus()
	{
		appState->UpdateEvents();
		UpdateUI();
	}

	void ApplicationUI::ClearPastEvents()
	{
		appState->ClearPastEvents();
		RefilterEvents();
		UpdateUI();
	}

	void ApplicationUI::ShowMetrics()
	{
		int total = appState->GetAllEventsCount();
		int completed = 0;
		int pending = 0;
		int pastDue = 0;

		for (int i = 0; i < total; ++i)
		{
			Event* targetEvent = appState->GetEvent(i);
			if (targetEvent->isCompleted)
			{
				completed++;
			}
			else if (targetEvent->isPastDeadline)
			{
				pastDue++;
			}
			else
			{
				pending++;
			}
		}

		wchar_t buffer[512];
		swprintf(buffer, 512,
			L"Статистика подій :\n"
			L"Загальна кількість подій : %d\n"
			L"Виконані : %d (%.1f%%)\n"
			L"Виконуються : %d (%.1f%%)\n"
			L"Прострочені : %d (%.1f%%)",
			total,
			completed, total > 0 ? (completed * 100.0f / total) : 0.0f,
			pending, total > 0 ? (pending * 100.0f / total) : 0.0f,
			pastDue, total > 0 ? (pastDue * 100.0f / total) : 0.0f
		);

		MessageBoxW(hMainWnd, buffer, L"Метрики подій", MB_OK | MB_ICONINFORMATION);
	}

	void ApplicationUI::SortEvents()
	{
		int sortType = SendDlgItemMessage(hMainWnd, ID_COMBO_SORT, CB_GETCURSEL, 0, 0) - 1;
		appState->SortEvents((AppState::SortType)sortType);
		EventList::Update();
	}
}

ApplicationUI.h:
#pragma once
#include <windows.h>
#include <commctrl.h>
#include "AppState.h"
#include "Event.h"

namespace ApplicationUserInterface
{
	class ApplicationUI
	{
	public:
		static HWND hMainWnd;

		static void Initialize(HWND hWnd, AppState* appState);
		static void HandleCommand(HWND hWnd, WPARAM wParam, LPARAM lParam);
		static void HandleTimer(HWND hWnd, WPARAM wParam, LPARAM lParam);
		static void UpdateUI();
		static void RefreshCategories();

	private:
		static void HandleCategoryFilter();
		static void HandleMenusCommand(HWND hWnd, WPARAM wParam, LPARAM lParam);
		static void HandleMainCommand(HWND hWnd, WPARAM wParam, LPARAM lParam);
		static void HandleAutoUpdateIntervalInput();
		static void HandleEventNotifications();

		static void CreateMainWindowControls(HWND hWnd);
		static void CreateAutoUpdateControls(HWND hWnd);
		static void CreateMainButtons(HWND& hWnd);
		static void CreateEventsSearch(HWND& hWnd);
		static void CreateFiltersComboBox(HWND& hWnd);
		static void CreateSortingComboBox(HWND& hWnd);
		static void CreateCategoryComboBox(HWND& hWnd);
		static void CreateMainWindowMenus(HWND hWnd);

		static void AddNewEvent();
		static void EditSelectedEvent();
		static void DeleteSelectedEvent();
		static void ToggleEventCompletion();
		static void UpdateEventsStatus();
		static void ClearPastEvents();
		static void ShowMetrics();
		static void RefilterEvents();
		static void SortEvents();

		static void ShowNotification(const Event& event, const std::wstring& message);

		static AppState* appState;
	};
}

Utilities.cpp:
#define UNICODE
#define _UNICODE

#include "Utilities.h"
#include "AppState.h"
#include <sstream>
#include <iomanip>
#include <shlobj.h> // For SHBrowseForFolder

// Time-related utilities

std::wstring SystemTimeToString(const SYSTEMTIME& st)
{
    std::wstringstream ss;
    ss << std::setfill(L'0')
        << std::setw(2) << st.wDay << L"/"
        << std::setw(2) << st.wMonth << L"/"
        << std::setw(4) << st.wYear << L" "
        << std::setw(2) << st.wHour << L":"
        << std::setw(2) << st.wMinute;
    return ss.str();
}

SYSTEMTIME GetCurrentSystemTime()
{
    SYSTEMTIME st;
    GetLocalTime(&st);
    return st;
}

bool IsSystemTimeInPast(const SYSTEMTIME& st)
{
    SYSTEMTIME now;
    GetLocalTime(&now);
    return CompareSystemTimes(st, now) < 0;
}

int CompareSystemTimes(const SYSTEMTIME& a, const SYSTEMTIME& b)
{
    // Compare years
    if (a.wYear < b.wYear) return -1;
    if (a.wYear > b.wYear) return 1;

    // Years equal, compare months
    if (a.wMonth < b.wMonth) return -1;
    if (a.wMonth > b.wMonth) return 1;

    // Months equal, compare days
    if (a.wDay < b.wDay) return -1;
    if (a.wDay > b.wDay) return 1;

    // Days equal, compare hours
    if (a.wHour < b.wHour) return -1;
    if (a.wHour > b.wHour) return 1;

    // Hours equal, compare minutes
    if (a.wMinute < b.wMinute) return -1;
    if (a.wMinute > b.wMinute) return 1;

    // Minutes equal, compare seconds
    if (a.wSecond < b.wSecond) return -1;
    if (a.wSecond > b.wSecond) return 1;

    // Seconds equal, compare milliseconds
    if (a.wMilliseconds < b.wMilliseconds) return -1;
    if (a.wMilliseconds > b.wMilliseconds) return 1;

    // All fields equal
    return 0;
}

bool IsLeapYear(WORD year)
{
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

int DaysInMonth(WORD year, WORD month)
{
    static const int daysPerMonth[12] = {
        31, 28, 31, 30, 31, 30,
        31, 31, 30, 31, 30, 31
    };

    if (month == 2 && IsLeapYear(year))
        return 29;

    return daysPerMonth[month - 1];
}

void NormalizeSystemTime(SYSTEMTIME* st)
{
    // Normalize milliseconds
    while (st->wMilliseconds >= 1000)
    {
        st->wMilliseconds -= 1000;
        st->wSecond++;
    }

    // Normalize seconds
    while (st->wSecond >= 60)
    {
        st->wSecond -= 60;
        st->wMinute++;
    }

    // Normalize minutes
    while (st->wMinute >= 60)
    {
        st->wMinute -= 60;
        st->wHour++;
    }

    // Normalize hours
    while (st->wHour >= 24)
    {
        st->wHour -= 24;
        st->wDay++;
    }

    // Normalize days
    while (true)
    {
        int dim = DaysInMonth(st->wYear, st->wMonth);
        if (st->wDay <= dim)
            break;

        st->wDay -= dim;
        st->wMonth++;
        if (st->wMonth > 12)
        {
            st->wMonth = 1;
            st->wYear++;
        }
    }

    // Normalize months
    while (st->wMonth > 12)
    {
        st->wMonth -= 12;
        st->wYear++;
    }
}

bool IsDueWithin(const SYSTEMTIME& deadline, int hours)
{
    if (hours <= 0) return false;

    SYSTEMTIME now;
    GetLocalTime(&now);

    // Convert both times to total minutes since epoch for easier comparison
    __int64 deadlineMinutes = SystemTimeToMinutes(deadline);
    __int64 nowMinutes = SystemTimeToMinutes(now);
    __int64 thresholdMinutes = deadlineMinutes - (hours * 60);

    return (nowMinutes >= thresholdMinutes) && (nowMinutes <= deadlineMinutes);
}

// Helper function to convert SYSTEMTIME to total minutes since year 1601
__int64 SystemTimeToMinutes(const SYSTEMTIME& st)
{
    SYSTEMTIME base = { 1601, 1, 0, 1, 0, 0, 0, 0 }; // Windows epoch
    FILETIME ftBase, ftCurrent;

    SystemTimeToFileTime(&base, &ftBase);
    SystemTimeToFileTime(&st, &ftCurrent);

    // Convert 100-nanosecond intervals to minutes
    ULARGE_INTEGER uliBase, uliCurrent;
    uliBase.LowPart = ftBase.dwLowDateTime;
    uliBase.HighPart = ftBase.dwHighDateTime;
    uliCurrent.LowPart = ftCurrent.dwLowDateTime;
    uliCurrent.HighPart = ftCurrent.dwHighDateTime;

    return (uliCurrent.QuadPart - uliBase.QuadPart) / (10000000 * 60);
}


// String utilities

std::wstring ToLower(const std::wstring& str)
{
    std::wstring lowerStr = str;
    std::transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower);
    return lowerStr;
}

bool ContainsString(const std::wstring& str, const std::wstring& searchStr)
{
    return ToLower(str).find(ToLower(searchStr)) != std::wstring::npos;
}


// Event comparison utilities

bool CompareEventsByDeadline(const Event& a, const Event& b)
{
    return CompareSystemTimes(a.deadline, b.deadline) < 0;
}

bool CompareEventsByPriority(const Event& a, const Event& b)
{
    if (a.priority != b.priority)
        return a.priority > b.priority; // Higher priority first
    return CompareEventsByDeadline(a, b); // Then by deadline
}

bool CompareEventsByName(const Event& a, const Event& b)
{
    return _wcsicmp(a.name.c_str(), b.name.c_str()) < 0;
}


// Get the executable folder path
std::wstring GetExecutableFolderPath()
{
    WCHAR path[MAX_PATH];
    if (GetModuleFileNameW(NULL, path, MAX_PATH))
    {
        std::wstring executablePath = path;
        size_t lastSlashPos = executablePath.find_last_of(L"\\");
        if (lastSlashPos != std::wstring::npos)
        {
            return executablePath.substr(0, lastSlashPos);
        }
    }
    return L"";
}

// Helper method to get save file path
std::wstring GetSaveFilePath(HWND hWnd, const wchar_t* defaultExt, const wchar_t* filter)
{
    OPENFILENAME ofn = { 0 };
    wchar_t szFile[MAX_PATH] = { 0 };

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1;
    ofn.lpstrDefExt = defaultExt;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    if (GetSaveFileName(&ofn))
    {
        return std::wstring(szFile);
    }
    return L"";
}

// Helper method to get open file path
std::wstring GetOpenFilePath(HWND hWnd, const wchar_t* defaultExt, const wchar_t* filter)
{
    OPENFILENAME ofn = { 0 };
    wchar_t szFile[MAX_PATH] = { 0 };

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hWnd;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1;
    ofn.lpstrDefExt = defaultExt;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    if (GetOpenFileName(&ofn))
    {
        return std::wstring(szFile);
    }
    return L"";
}

// Helper method to select a folder
std::wstring GetFolderPath(HWND hWnd)
{
    BROWSEINFO bi = { 0 };
    bi.hwndOwner = hWnd;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;

    LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
    if (pidl != NULL)
    {
        wchar_t path[MAX_PATH];
        SHGetPathFromIDList(pidl, path);

        // Free memory
        CoTaskMemFree(pidl);

        return std::wstring(path);
    }
    return L"";
}

// Convert UTF-8 or ANSI to UTF-16
std::wstring ConvertToWideStringFromUtf8OrAnsi(const char* buffer, size_t size)
{
    int required = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, buffer, size, NULL, 0);
    std::wstring result;

    if (required > 0)
    {
        result.resize(required);
        MultiByteToWideChar(CP_UTF8, 0, buffer, size, &result[0], required);
    }
    else
    {
        required = MultiByteToWideChar(CP_ACP, 0, buffer, size, NULL, 0);
        if (required > 0)
        {
            result.resize(required);
            MultiByteToWideChar(CP_ACP, 0, buffer, size, &result[0], required);
        }
    }

    return result;
}

// Trims whitespace from a string (both ends)
void TrimString(std::wstring& str)
{
    // Trim leading spaces
    size_t start = str.find_first_not_of(L" \t\r\n");
    if (start != std::wstring::npos)
    {
        str.erase(0, start);
    }

    // Trim trailing spaces
    size_t end = str.find_last_not_of(L" \t\r\n");
    if (end != std::wstring::npos)
    {
        str.erase(end + 1);
    }
}

std::wstring GetTranslatedErrorMessage(const std::exception& e)
{
    try
    {
        // For UTF-8 encoded exception messages
        std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
        return converter.from_bytes(e.what());
    }
    catch (...)
    {
        // Fallback for non-UTF-8 strings
        int size_needed = MultiByteToWideChar(CP_ACP, 0, e.what(), -1, NULL, 0);
        std::wstring wstrTo(size_needed, 0);
        MultiByteToWideChar(CP_ACP, 0, e.what(), -1, &wstrTo[0], size_needed);
        return wstrTo;
    }
}

int GetClientHeight(HWND hWnd)
{
    RECT rc;
    GetClientRect(hWnd, &rc);
    return rc.bottom - rc.top;
}

void CenterWindow(HWND hWnd)
{
    RECT rc;
    GetWindowRect(hWnd, &rc);

    // Get screen dimensions
    int screenWidth = GetSystemMetrics(SM_CXSCREEN);
    int screenHeight = GetSystemMetrics(SM_CYSCREEN);

    // Calculate new position
    int x = (screenWidth - (rc.right - rc.left)) / 2;
    int y = (screenHeight - (rc.bottom - rc.top)) / 2;

    // Set new position
    SetWindowPos(hWnd, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

utulities.h:
#pragma once
#include <windows.h>
#include <string>
#include <algorithm>
#include "Event.h"

// Time-related utilities
std::wstring SystemTimeToString(const SYSTEMTIME& st);
SYSTEMTIME GetCurrentSystemTime();
bool IsSystemTimeInPast(const SYSTEMTIME& st);
int CompareSystemTimes(const SYSTEMTIME& a, const SYSTEMTIME& b);
bool IsLeapYear(WORD year);
int DaysInMonth(WORD year, WORD month);
void NormalizeSystemTime(SYSTEMTIME* st);
bool IsDueWithin(const SYSTEMTIME& time, int hours);
__int64 SystemTimeToMinutes(const SYSTEMTIME& st);

// String utilities
std::wstring ToLower(const std::wstring& str);
bool ContainsString(const std::wstring& str, const std::wstring& searchStr);

// Event comparison utilities
bool CompareEventsByDeadline(const Event& a, const Event& b);
bool CompareEventsByPriority(const Event& a, const Event& b);
bool CompareEventsByName(const Event& a, const Event& b);
std::wstring GetExecutableFolderPath();

std::wstring GetFolderPath(HWND hWnd);
std::wstring GetSaveFilePath(HWND hWnd, const wchar_t* defaultExt = L".txt", const wchar_t* filter = L"Txt Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0");
std::wstring GetOpenFilePath(HWND hWnd, const wchar_t* defaultExt = L".txt", const wchar_t* filter = L"Txt Files (*.txt)\0*.txt\0All Files (*.*)\0*.*\0");

void TrimString(std::wstring& str);
std::wstring ConvertToWideStringFromUtf8OrAnsi(const char* buffer, size_t size);

std::wstring GetTranslatedErrorMessage(const std::exception& e);

int GetClientHeight(HWND hWnd);
void CenterWindow(HWND hWnd);

EventDialog.cpp:
#define UNICODE
#define _UNICODE

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include "resource.h"
#include "appState.h"
#include "EventDialog.h"
#include "Utilities.h"
#include "ApplicationUI.h"
#pragma comment(lib, "comctl32.lib")

// Common

extern AppState* appState;
bool isDateValid = true;
int inputDialogUpdateIntervalSec = 3;
bool editingEvent = false;

// Styles

static HBRUSH hBrushWarning = NULL;
static HBRUSH hBrushNormal = NULL;
static HFONT hBoldFont = NULL;
static HFONT hDialogFont = NULL;

bool EventDialog::Show(HWND hParent, Event* event, Event* originalEvent)
{
	editingEvent = originalEvent != nullptr;

	return DialogBoxParam(
		GetModuleHandle(NULL),
		MAKEINTRESOURCE(IDD_EVENT_DIALOG),
		hParent,
		DialogProc,
		reinterpret_cast<LPARAM>(event)
	) == IDOK;
}

INT_PTR CALLBACK EventDialog::DialogProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	static Event* event = NULL;

	switch (msg)
	{
	case WM_INITDIALOG:
		event = reinterpret_cast<Event*>(lParam);
		OnInitDialog(hDlg, event);
		return TRUE;

	case WM_CTLCOLORSTATIC:
		if ((HWND)lParam == GetDlgItem(hDlg, IDC_STATIC_DATE_WARNING))
		{
			HDC hdc = (HDC)wParam;

			// If you have a bold font, select it
			if (hBoldFont)
			{
				SelectObject(hdc, hBoldFont);
			}
			else
			{
				// Reset to default font (if needed)
				SelectObject(hdc, GetStockObject(SYSTEM_FONT));
			}
			if (!isDateValid)
				SetTextColor(hdc, RGB(255, 0, 0)); // Red for warnings
			else
				SetTextColor(hdc, RGB(0, 128, 0)); // Green for valid
			SetBkMode(hdc, TRANSPARENT);
			return (INT_PTR)GetSysColorBrush(COLOR_BTNFACE);
		}
		break;


	case WM_NOTIFY:
	{
		LPNMHDR pnmh = (LPNMHDR)lParam;
		if (pnmh->code == DTN_DATETIMECHANGE &&
			(pnmh->idFrom == IDC_DATEPICKER || pnmh->idFrom == IDC_TIMEPICKER))
		{
			UpdateDateTimeWarning(hDlg);
			return TRUE;
		}
		break;
	}

	case WM_TIMER:
		if (wParam == ID_UPDATE_TIMER)
		{
			UpdateDateTimeWarning(hDlg);
			return TRUE;
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_CHECK_RECURRING:
			if (HIWORD(wParam) == BN_CLICKED)
			{
				BOOL isChecked = IsDlgButtonChecked(hDlg, IDC_CHECK_RECURRING);
				EnableWindow(GetDlgItem(hDlg, IDC_COMBO_INTERVAL), isChecked);
				EnableWindow(GetDlgItem(hDlg, IDC_EDIT_CUSTOM_DAYS),
					isChecked &&
					GetSelectedReccurenceInterval(hDlg) == RecurrenceInterval::Custom);
			}
			return TRUE;

		case IDC_COMBO_INTERVAL:
			if (HIWORD(wParam) == CBN_SELCHANGE)
			{
				EnableWindow(GetDlgItem(hDlg, IDC_EDIT_CUSTOM_DAYS),
					GetSelectedReccurenceInterval(hDlg) == RecurrenceInterval::Custom);
			}
			return TRUE;

		case IDC_ADD_CATEGORY_BTN:
			if (HIWORD(wParam) == BN_CLICKED)
			{
				AddNewCategory(hDlg);
			}
			return TRUE;

		case IDC_EDIT_NAME:
		case IDC_EDIT_DESC:
		case IDC_EDIT_NOTES:
			if (HIWORD(wParam) == EN_CHANGE)
			{
				UpdateCharCount(hDlg, LOWORD(wParam));
			}
			return TRUE;

		case ID_CREATE_EVENT_BTN:
			if (ValidateFields(hDlg))
			{
				OnOK(hDlg, event);
				EndDialog(hDlg, IDOK);
			}
			return TRUE;

		case IDCANCEL:
		case ID_CANCEL_EVENT_CREATION_BTN:
			EndDialog(hDlg, IDCANCEL);
			return TRUE;
		}
		break;

	case WM_DESTROY:
		ClearResources(hDlg);
		break;
	}
	return FALSE;
}

void EventDialog::ClearResources(HWND hDlg)
{
	KillTimer(hDlg, ID_UPDATE_TIMER);
	// Clean up brushes
	if (hBrushWarning) DeleteObject(hBrushWarning);
	if (hBrushNormal) DeleteObject(hBrushNormal);
	if (hBoldFont)
	{
		DeleteObject(hBoldFont);
		hBoldFont = NULL;
	}

	if (hDialogFont)
	{
		DeleteObject(hDialogFont);
		hDialogFont = NULL;
	}
}

void EventDialog::OnInitDialog(HWND hDlg, Event* event)
{
	ConfigureStaticLabelsStyle(hDlg);

	// Set text fields
	SetDlgItemText(hDlg, IDC_EDIT_NAME, event->name.c_str());
	SetDlgItemText(hDlg, IDC_EDIT_DESC, event->description.c_str());
	SetDlgItemText(hDlg, IDC_EDIT_NOTES, event->notes.c_str());

	// Set text limits
	SendDlgItemMessage(hDlg, IDC_EDIT_NAME, EM_SETLIMITTEXT, MAX_EVENT_NAME_LENGTH, 0);
	SendDlgItemMessage(hDlg, IDC_EDIT_DESC, EM_SETLIMITTEXT, MAX_EVENT_DESC_LENGTH, 0);
	SendDlgItemMessage(hDlg, IDC_EDIT_NOTES, EM_SETLIMITTEXT, MAX_EVENT_NOTES_LENGTH, 0);

	HWND hDate = GetDlgItem(hDlg, IDC_DATEPICKER);
	HWND hTime = GetDlgItem(hDlg, IDC_TIMEPICKER);

	// Initialize date picker
	DateTime_SetFormat(hDate, L"dd/MM/yyyy");
	DateTime_SetSystemtime(hDate, GDT_VALID, &event->deadline);

	// Initialize time picker 
	SYSTEMTIME stTime = event->deadline;
	stTime.wSecond = 0;
	stTime.wMilliseconds = 0;

	DateTime_SetFormat(hTime, L"HH:mm");
	DateTime_SetSystemtime(hTime, GDT_VALID, &stTime);

	// Populate the category combo box
	HWND hCategory = GetDlgItem(hDlg, IDC_COMBO_CATEGORY);
	for (size_t i = 0; i < AppConfig::GetCategoryCount(); i++)
	{
		SendMessage(hCategory, CB_ADDSTRING, 0, (LPARAM)AppConfig::GetCategory(i));
	}

	// Set the current category in the combo box
	int index = SendMessage(hCategory, CB_FINDSTRINGEXACT, -1, (LPARAM)event->category.c_str());
	if (index != CB_ERR)
		SendMessage(hCategory, CB_SETCURSEL, index, 0);
	else if (AppConfig::GetCategoryCount() > 0)
		SendMessage(hCategory, CB_SETCURSEL, 0, 0);

	// Populate the priority combo box
	HWND hPriority = GetDlgItem(hDlg, IDC_COMBO_PRIORITY);
	SendMessage(hPriority, CB_ADDSTRING, 0, (LPARAM)L"Низький");
	SendMessage(hPriority, CB_ADDSTRING, 0, (LPARAM)L"Середній");
	SendMessage(hPriority, CB_ADDSTRING, 0, (LPARAM)L"Високий");
	SendMessage(hPriority, CB_ADDSTRING, 0, (LPARAM)L"Критичний");
	SendMessage(hPriority, CB_SETCURSEL, (WPARAM)event->priority, 0);

	// Set recurring and completed checkbox states
	CheckDlgButton(hDlg, IDC_CHECK_RECURRING, event->isRecurring ? BST_CHECKED : BST_UNCHECKED);

	// Populate recurrence interval combo box
	HWND hInterval = GetDlgItem(hDlg, IDC_COMBO_INTERVAL);
	SendMessage(hInterval, CB_ADDSTRING, 0, (LPARAM)L"Щоденна");
	SendMessage(hInterval, CB_ADDSTRING, 0, (LPARAM)L"Щотижнева");
	SendMessage(hInterval, CB_ADDSTRING, 0, (LPARAM)L"Щомісячна");
	SendMessage(hInterval, CB_ADDSTRING, 0, (LPARAM)L"Щорічна");
	SendMessage(hInterval, CB_ADDSTRING, 0, (LPARAM)L"Власний інтервал");

	if (event->recurrenceInterval != RecurrenceInterval::None)
		SendMessage(hInterval, CB_SETCURSEL, (WPARAM)((int)event->recurrenceInterval - 1), 0);
	else
		SendMessage(hInterval, CB_SETCURSEL, 0, 0);


	// Enable/disable recurrence interval and custom days input based on recurrence checkbox
	EnableWindow(hInterval, event->isRecurring);

	EnableWindow(GetDlgItem(hDlg, IDC_EDIT_CUSTOM_DAYS),
		event->isRecurring &&
		GetSelectedReccurenceInterval(hDlg) == RecurrenceInterval::Custom);
	// Set custom recurrence days
	WCHAR buffer[32];
	swprintf(buffer, 32, L"%d", event->customRecurrenceDays);
	SetDlgItemText(hDlg, IDC_EDIT_CUSTOM_DAYS, buffer);

	// Set the warning text color
	HWND hWarning = GetDlgItem(hDlg, IDC_STATIC_DATE_WARNING);
	HDC hdc = GetDC(hWarning);
	SetTextColor(hdc, RGB(0, 0, 0)); // Default black
	ReleaseDC(hWarning, hdc);

	// Update character count for name, description, and notes fields
	UpdateCharCount(hDlg, IDC_EDIT_NAME);
	UpdateCharCount(hDlg, IDC_EDIT_DESC);
	UpdateCharCount(hDlg, IDC_EDIT_NOTES);

	hBoldFont = CreateFont(0, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
		DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
		DEFAULT_PITCH | FF_DONTCARE, L"MS Shell Dlg");

	hBrushWarning = CreateSolidBrush(RGB(255, 255, 255));
	hBrushNormal = CreateSolidBrush(RGB(255, 255, 255));

	SetTimer(hDlg, ID_UPDATE_TIMER, inputDialogUpdateIntervalSec * 1000, NULL);
	UpdateDateTimeWarning(hDlg);

	if (editingEvent)
	{
		SetDlgItemText(hDlg, ID_CREATE_EVENT_BTN, L"Змінити");
	}
}

void EventDialog::ConfigureStaticLabelsStyle(HWND hDlg)
{
	hDialogFont = CreateFont(
		16, 0, 0, 0,         // Height, Width (0=default), Escapement, Orientation
		FW_BOLD,              // Bold weight
		FALSE, FALSE, FALSE,  // Italic, Underline, Strikeout
		DEFAULT_CHARSET,
		OUT_DEFAULT_PRECIS,
		CLIP_DEFAULT_PRECIS,
		DEFAULT_QUALITY,
		DEFAULT_PITCH | FF_DONTCARE,
		L"MS Shell Dlg"       // Same font family as dialog
	);

	SendDlgItemMessage(hDlg, IDC_EVENT_NAME_LABEL, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_EVENT_DESC_LABEL, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_EVENT_NOTES_LABEL, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_EVENT_DATE_LABEL, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_EVENT_INTERVAL_LABEL, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_EVENT_CATEGORY_LABEL, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_EVENT_TIME_LABEL, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_EVENT_PRIORITY_LABEL, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_EVENT_DAYS_LABEL, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_STATIC_DATE_NOTE, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, IDC_CHECK_RECURRING, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, ID_CREATE_EVENT_BTN, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
	SendDlgItemMessage(hDlg, ID_CANCEL_EVENT_CREATION_BTN, WM_SETFONT, (WPARAM)hDialogFont, TRUE);
}

void EventDialog::UpdateDateTimeWarning(HWND hDlg)
{
	SYSTEMTIME stDate, stTime, stNow;
	GetLocalTime(&stNow);

	// Get current values from pickers
	DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_DATEPICKER), &stDate);
	DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_TIMEPICKER), &stTime);

	// Combine date and time
	stDate.wHour = stTime.wHour;
	stDate.wMinute = stTime.wMinute;
	stDate.wSecond = 0;
	stDate.wMilliseconds = 0;

	// Compare with current time
	isDateValid = !IsSystemTimeInPast(stDate);

	HWND hWarning = GetDlgItem(hDlg, IDC_STATIC_DATE_WARNING);

	// Set new text
	SetWindowText(hWarning,
		isDateValid ? L"✓ Дата/час коректні"
		: L"⚠ Увага: Обрані дата/час вже минули!");

	// Force complete redraw
	RedrawWindow(hWarning, NULL, NULL,
		RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
}



void EventDialog::OnOK(HWND hDlg, Event* event)
{
	WCHAR buffer[1025];

	GetDlgItemText(hDlg, IDC_EDIT_NAME, buffer, MAX_EVENT_NAME_LENGTH + 1);
	event->name = buffer;

	GetDlgItemText(hDlg, IDC_EDIT_DESC, buffer, MAX_EVENT_DESC_LENGTH + 1);
	event->description = buffer;

	GetDlgItemText(hDlg, IDC_EDIT_NOTES, buffer, MAX_EVENT_NOTES_LENGTH + 1);
	event->notes = buffer;

	int sel = SendDlgItemMessage(hDlg, IDC_COMBO_CATEGORY, CB_GETCURSEL, 0, 0);
	if (sel != CB_ERR)
	{
		SendDlgItemMessage(hDlg, IDC_COMBO_CATEGORY, CB_GETLBTEXT, sel, (LPARAM)buffer);
		event->category = buffer;
	}

	SYSTEMTIME stDate, stTime;
	DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_DATEPICKER), &stDate);
	DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_TIMEPICKER), &stTime);

	event->deadline.wYear = stDate.wYear;
	event->deadline.wMonth = stDate.wMonth;
	event->deadline.wDay = stDate.wDay;
	event->deadline.wHour = stTime.wHour;
	event->deadline.wMinute = stTime.wMinute;
	event->deadline.wMilliseconds = 0;
	event->deadline.wDayOfWeek = 0;
	event->deadline.wSecond = 0;

	event->priority = (EventPriority)SendDlgItemMessage(hDlg, IDC_COMBO_PRIORITY, CB_GETCURSEL, 0, 0);
	event->isRecurring = IsDlgButtonChecked(hDlg, IDC_CHECK_RECURRING) == BST_CHECKED;
	event->recurrenceInterval = GetSelectedReccurenceInterval(hDlg);
	event->ResetNotificationStates();

	if (event->recurrenceInterval == RecurrenceInterval::Custom)
	{
		GetDlgItemText(hDlg, IDC_EDIT_CUSTOM_DAYS, buffer, 32);
		event->customRecurrenceDays = _wtoi(buffer);
	}
}

bool EventDialog::ValidateFields(HWND hDlg)
{
	WCHAR buffer[1025];  // Buffer for reading text

	// Validate event name
	GetDlgItemText(hDlg, IDC_EDIT_NAME, buffer, MAX_EVENT_NAME_LENGTH + 1);
	if (wcslen(buffer) == 0)
	{
		MessageBox(hDlg, L"Назва події не може бути порожньою", L"Помилка створення події", MB_ICONERROR);
		return false;
	}

	SYSTEMTIME stDate, stTime;
	DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_DATEPICKER), &stDate);
	DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_TIMEPICKER), &stTime);

	FILETIME ftEvent, ftNow;
	stDate.wHour = stTime.wHour;
	stDate.wMinute = stTime.wMinute;

	// Check if the event date/time is in the past
	if (IsSystemTimeInPast(stDate))
	{
		MessageBox(hDlg, L"Дата/час події не можуть бути минулими.", L"Помилка створення події", MB_ICONERROR);
		return false;
	}

	// Check for recurrence and custom days validity
	if (IsDlgButtonChecked(hDlg, IDC_CHECK_RECURRING) &&
		GetSelectedReccurenceInterval(hDlg) == RecurrenceInterval::Custom)
	{
		GetDlgItemText(hDlg, IDC_EDIT_CUSTOM_DAYS, buffer, 32);
		if (_wtoi(buffer) <= 0)
		{
			MessageBox(hDlg, L"Власний інтервал повторення події повинен бути більшим за 0 (днів)", L"Помилка створення події", MB_ICONERROR);
			return false;
		}
	}

	return true;
}

RecurrenceInterval EventDialog::GetSelectedReccurenceInterval(HWND hDlg)
{
	return (RecurrenceInterval)(SendDlgItemMessage(hDlg, IDC_COMBO_INTERVAL, CB_GETCURSEL, 0, 0) + 1);
}


void EventDialog::UpdateCharCount(HWND hDlg, int controlId)
{
	int maxLen = 0;
	int staticId = 0;

	// Determine the maximum length and static label ID based on the control
	switch (controlId)
	{
	case IDC_EDIT_NAME:
		maxLen = MAX_EVENT_NAME_LENGTH;
		staticId = IDC_STATIC_NAME_COUNT;
		break;
	case IDC_EDIT_DESC:
		maxLen = MAX_EVENT_DESC_LENGTH;
		staticId = IDC_STATIC_DESC_COUNT;
		break;
	case IDC_EDIT_NOTES:
		maxLen = MAX_EVENT_NOTES_LENGTH;
		staticId = IDC_STATIC_NOTES_COUNT;
		break;
	default:
		return;
	}

	// Get the current length of the text in the field
	int len = GetWindowTextLength(GetDlgItem(hDlg, controlId));

	// Update the static label with the current length and max length
	WCHAR buffer[32];
	swprintf(buffer, 32, L"%d/%d", len, maxLen);
	SetDlgItemText(hDlg, staticId, buffer);
}


#pragma region Categories

void EventDialog::AddNewCategory(HWND hDlg)
{
	WCHAR buffer[MAX_EVENT_CATEGORY_LENGTH] = { 0 };

	// Show the input dialog to get the new category name
	if (DialogBoxParam(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_INPUT_DIALOG),
		hDlg, InputCategoryDlgProc, (LPARAM)buffer) == IDOK)
	{
		// Try to add the category through AppConfig method
		if (AppConfig::AddCategory(buffer))
		{
			// If category is successfully added, update the combo box
			HWND hCombo = GetDlgItem(hDlg, IDC_COMBO_CATEGORY);
			SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)buffer);
			SendMessage(hCombo, CB_SETCURSEL, AppConfig::GetCategoryCount() - 1, 0);
			ApplicationUserInterface::ApplicationUI::RefreshCategories();
		}
		else
		{
			// Show message if the category already exists or exceeds the max length
			MessageBox(hDlg,
				L"Не вдалося створити категорію. Переконайтесь що ім'я категорії унікальне та не перевищує максимальний допустимий ліміт символів (64).",
				L"Помилка створення категорії", MB_ICONERROR);
		}
	}
}

INT_PTR CALLBACK EventDialog::InputCategoryDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	static WCHAR* pBuffer = NULL;

	switch (msg)
	{
	case WM_INITDIALOG:
		pBuffer = (WCHAR*)lParam;
		SendDlgItemMessage(hDlg, IDC_EDIT_CATEGORY, EM_SETLIMITTEXT, MAX_EVENT_CATEGORY_LENGTH, 0);
		return TRUE;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
			GetDlgItemText(hDlg, IDC_EDIT_CATEGORY, pBuffer, MAX_EVENT_CATEGORY_LENGTH);
			if (wcslen(pBuffer) == 0)
			{
				MessageBox(hDlg, L"Ім'я нової категорії не може бути порожнім. Будь-ласка введіть коректне ім'я категорії.", L"Помилка створення категорії", MB_ICONERROR);
				return TRUE;
			}
			EndDialog(hDlg, IDOK);
			return TRUE;

		case IDCANCEL:
			EndDialog(hDlg, IDCANCEL);
			return TRUE;
		}
		break;
	}
	return FALSE;
}

#pragma endregion

EventDialog.h:

#pragma once
#include <windows.h>
#include "Event.h"

class EventDialog
{
public:
	static bool Show(HWND hParent, Event* event, Event* originalEvent = nullptr);

private:
	static INT_PTR CALLBACK DialogProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK InputCategoryDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

	static void OnInitDialog(HWND hDlg, Event* event);
	static void ConfigureStaticLabelsStyle(HWND hDlg);
	static void ClearResources(HWND hDlg);

	static void OnOK(HWND hDlg, Event* event);
	static bool ValidateFields(HWND hDlg);
	static void UpdateCharCount(HWND hDlg, int controlId);
	static RecurrenceInterval GetSelectedReccurenceInterval(HWND hDlg);

	static void AddNewCategory(HWND hDlg);
	static void UpdateDateTimeWarning(HWND hDlg);
};

EventDetailsDialog.cpp:
#include "EventDetailsDialog.h"
#include "Windows.h"
#include "resource.h"
#include <CommCtrl.h>
#include <string>
#include <sstream>
#include <iomanip>
#include "Utilities.h"

const int EventDetailsDialog::LABEL_FONT_SIZE = 18;
const int EventDetailsDialog::LABEL_FONT_WEIGHT = FW_NORMAL;
const wchar_t* EventDetailsDialog::LABEL_FONT_FAMILY = L"Arial Unicode MS";
const Event* EventDetailsDialog::currentEvent = nullptr;

void EventDetailsDialog::Show(HWND hParent, const Event* event)
{
    currentEvent = event;

    DialogBoxParam(GetModuleHandle(NULL),
        MAKEINTRESOURCE(IDD_EVENT_DETAILS_DIALOG),
        hParent,
        DialogProc,
        reinterpret_cast<LPARAM>(event));
}

INT_PTR CALLBACK EventDetailsDialog::DialogProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        OnInitDialog(hDlg, reinterpret_cast<const Event*>(lParam));
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
        {
            // Clean up fonts
            HFONT hTitleFont = (HFONT)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            HFONT hLabelFont = (HFONT)GetWindowLongPtr(hDlg, GWLP_USERDATA + sizeof(LONG_PTR));
            DeleteObject(hTitleFont);
            DeleteObject(hLabelFont);

            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }

        case IDC_INFO_COPY_DETAILS:
            CopyDetailsToClipboard(hDlg, reinterpret_cast<const Event*>(currentEvent));
            return TRUE;
        }
        break;

    case WM_CTLCOLORSTATIC:
    {
        HDC hdc = (HDC)wParam;
        HWND hwnd = (HWND)lParam;

        if (hwnd == GetDlgItem(hDlg, IDC_EVENT_INFO_NAME))
        {
            SetTextColor(hdc, RGB(0, 0, 128)); // Dark blue for title
            SetBkMode(hdc, TRANSPARENT);
            return (INT_PTR)GetSysColorBrush(COLOR_BTNFACE);
        }
        return FALSE;
    }

    case WM_DRAWITEM:
        if ((UINT)wParam == IDC_INFO_PRIORITY_INDICATOR)
        {
            LPDRAWITEMSTRUCT lpDrawItem = (LPDRAWITEMSTRUCT)lParam;
            Event* event = reinterpret_cast<Event*>(GetWindowLongPtr(hDlg, GWLP_USERDATA));

            HBRUSH hBrush = CreateSolidBrush(GetPriorityColor(event->priority));
            FillRect(lpDrawItem->hDC, &lpDrawItem->rcItem, hBrush);
            DeleteObject(hBrush);
            return TRUE;
        }
        break;
    }
    return FALSE;
}

void EventDetailsDialog::OnInitDialog(HWND hDlg, const Event* event)
{
    // Store event pointer in window data
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)event);

    // Create fonts
    HFONT hTitleFont = CreateFont(20, 0, 0, 0, FW_SEMIBOLD, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        DEFAULT_QUALITY, DEFAULT_PITCH, L"Segoe UI");

    HFONT hLabelFont = CreateFont(LABEL_FONT_SIZE, 0, 0, 0, LABEL_FONT_WEIGHT, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        DEFAULT_QUALITY, DEFAULT_PITCH, LABEL_FONT_FAMILY);

    // Set title with larger font
    SetWindowText(hDlg, (L"Деталі події: " + event->name).c_str());
    SendDlgItemMessage(hDlg, IDC_EVENT_INFO_NAME, WM_SETFONT, (WPARAM)hTitleFont, TRUE);
    SetDlgItemText(hDlg, IDC_EVENT_INFO_NAME, (L"📌 " + event->name).c_str());

    // Set icon based on status
    HICON hIcon = LoadIcon(NULL, event->isCompleted ? IDI_INFORMATION :
        (event->isPastDeadline ? IDI_WARNING : IDI_QUESTION));
    SendDlgItemMessage(hDlg, IDC_EVENT_INFO_ICON, STM_SETICON, (WPARAM)hIcon, 0);

    // Apply label font to all static text controls (labels)
    EnumChildWindows(hDlg, [](HWND hWnd, LPARAM lParam) -> BOOL
        {
            wchar_t className[256];
            GetClassName(hWnd, className, 256);

            // Apply to static text controls that aren't the title
            if (wcscmp(className, L"Static") == 0 &&
                GetDlgCtrlID(hWnd) != IDC_EVENT_INFO_NAME)
            {
                SendMessage(hWnd, WM_SETFONT, (WPARAM)lParam, TRUE);
            }
            return TRUE;
        }, (LPARAM)hLabelFont);

    // Set description
    SetDlgItemText(hDlg, IDC_EVENT_INFO_DESCRIPTION,
        event->description.empty() ? L"Опису немає" : event->description.c_str());

    // Set status
    SetDlgItemText(hDlg, IDC_EVENT_INFO_STATUS, GetStatusString(event).c_str());
    SetStatusIndicatorColor(hDlg, event);

    // Set priority
    SetDlgItemText(hDlg, IDC_EVENT_INFO_PRIORITY, GetPriorityString(event->priority).c_str());
    SetPriorityIndicatorColor(hDlg, event->priority);

    // Set dates
    SetDlgItemText(hDlg, IDC_EVENT_INFO_CREATION_DATE,
        (L"📅 " + SystemTimeToString(event->creationDate)).c_str());

    std::wstring deadlineText = L"⏰ " + SystemTimeToString(event->deadline);
    if (event->isPastDeadline && !event->isCompleted)
    {
        deadlineText += L" (прострочено)";
    }
    SetDlgItemText(hDlg, IDC_EVENT_INFO_DEADLINE, deadlineText.c_str());

    // Set category
    SetDlgItemText(hDlg, IDC_EVENT_INFO_CATEGORY, (L"📁 " + event->category).c_str());

    // Set recurrence
    if (event->isRecurring)
    {
        SetDlgItemText(hDlg, IDC_EVENT_INFO_RECURRENCE,
            (L"🔁 " + GetRecurrenceString(event->recurrenceInterval,
                event->customRecurrenceDays)).c_str());
    }
    else
    {
        SetDlgItemText(hDlg, IDC_EVENT_INFO_RECURRENCE, L"🚫 Без повторень");
    }

    // Set notes
    SetDlgItemText(hDlg, IDC_EVENT_INFO_NOTES,
        event->notes.empty() ? L"Нотаток немає" : event->notes.c_str());

    // Set time remaining
    UpdateTimeRemaining(hDlg, event);

    // Center dialog
    CenterWindow(hDlg);

    // Store fonts to delete them later
    SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)hTitleFont);
    SetWindowLongPtr(hDlg, GWLP_USERDATA + sizeof(LONG_PTR), (LONG_PTR)hLabelFont);
}

void EventDetailsDialog::SetStatusIndicatorColor(HWND hDlg, const Event* event)
{
    HWND hIndicator = GetDlgItem(hDlg, IDC_INFO_STATUS_INDICATOR);
    HDC hdc = GetDC(hIndicator);
    RECT rc;
    GetClientRect(hIndicator, &rc);

    HBRUSH hBrush;
    if (event->isCompleted)
    {
        hBrush = CreateSolidBrush(COLOR_COMPLETED); // Green
    }
    else if (event->isPastDeadline)
    {
        hBrush = CreateSolidBrush(COLOR_OVERDUE); // Red
    }
    else
    {
        hBrush = CreateSolidBrush(COLOR_IN_PROGRESS); // Blue
    }

    FillRect(hdc, &rc, hBrush);
    DeleteObject(hBrush);
    ReleaseDC(hIndicator, hdc);
}

void EventDetailsDialog::SetPriorityIndicatorColor(HWND hDlg, EventPriority priority)
{
    HWND hIndicator = GetDlgItem(hDlg, IDC_INFO_PRIORITY_INDICATOR);
    HDC hdc = GetDC(hIndicator);
    RECT rc;
    GetClientRect(hIndicator, &rc);

    HBRUSH hBrush = CreateSolidBrush(GetPriorityColor(priority));
    FillRect(hdc, &rc, hBrush);

    DeleteObject(hBrush);
    ReleaseDC(hIndicator, hdc);
}

void EventDetailsDialog::UpdateTimeRemaining(HWND hDlg, const Event* event)
{
    if (event->isCompleted)
    {
        SetDlgItemText(hDlg, IDC_INFO_TIME_REMAINING, L"✅ Подію виконано");
        return;
    }

    SYSTEMTIME now;
    GetLocalTime(&now);

    FILETIME ftNow, ftDeadline;
    SystemTimeToFileTime(&now, &ftNow);
    SystemTimeToFileTime(&event->deadline, &ftDeadline);

    ULARGE_INTEGER ulNow, ulDeadline;
    ulNow.LowPart = ftNow.dwLowDateTime;
    ulNow.HighPart = ftNow.dwHighDateTime;
    ulDeadline.LowPart = ftDeadline.dwLowDateTime;
    ulDeadline.HighPart = ftDeadline.dwHighDateTime;

    LONGLONG diff = ulDeadline.QuadPart - ulNow.QuadPart;

    if (diff <= 0)
    {
        SetDlgItemText(hDlg, IDC_INFO_TIME_REMAINING, L"❌ Час виконання події вже минув");
        return;
    }

    diff /= 10000000LL; // Convert to seconds

    int days = diff / 86400;
    int hours = (diff % 86400) / 3600;
    int minutes = (diff % 3600) / 60;

    std::wstring timeRemaining;
    if (days > 0)
    {
        timeRemaining = L"⏳ Залишилось: " + std::to_wstring(days) + L" дн. " +
            std::to_wstring(hours) + L" год.";
    }
    else if (hours > 0)
    {
        timeRemaining = L"⏳ Залишилось: " + std::to_wstring(hours) + L" год. " +
            std::to_wstring(minutes) + L" хв.";
    }
    else
    {
        timeRemaining = L"⏳ Залишилось: " + std::to_wstring(minutes) + L" хв.";
    }

    SetDlgItemText(hDlg, IDC_INFO_TIME_REMAINING, timeRemaining.c_str());
}

std::wstring EventDetailsDialog::GetStatusString(const Event* event)
{
    if (event->isCompleted)
    {
        return L"✅ Виконано вчасно";
    }
    return event->isPastDeadline ? L"❌ Прострочено" : L"🟢 Виконується";
}

COLORREF EventDetailsDialog::GetPriorityColor(EventPriority priority)
{
    switch (priority)
    {
    case EventPriority::Critical: return COLOR_PRIORITY_CRITICAL;
    case EventPriority::High:    return COLOR_PRIORITY_HIGH;
    case EventPriority::Medium:  return COLOR_PRIORITY_MEDIUM;
    case EventPriority::Low:     return COLOR_PRIORITY_LOW;
    default:                     return COLOR_PRIORITY_NONE;
    }
}

void EventDetailsDialog::UpdateStatusBar(HWND hStatusBar, const Event* event)
{
    std::wstring status = L"🔄 Статус: " + event->GetStatusString();
    SendMessage(hStatusBar, SB_SETTEXT, 0, (LPARAM)status.c_str());

    std::wstring priority = L"⚡ Пріоритет: " + GetPriorityString(event->priority);
    SendMessage(hStatusBar, SB_SETTEXT, 1, (LPARAM)priority.c_str());

    SYSTEMTIME now;
    GetLocalTime(&now);

    FILETIME ftNow, ftDeadline;
    SystemTimeToFileTime(&now, &ftNow);
    SystemTimeToFileTime(&event->deadline, &ftDeadline);

    ULARGE_INTEGER ulNow, ulDeadline;
    ulNow.LowPart = ftNow.dwLowDateTime;
    ulNow.HighPart = ftNow.dwHighDateTime;
    ulDeadline.LowPart = ftDeadline.dwLowDateTime;
    ulDeadline.HighPart = ftDeadline.dwHighDateTime;

    LONGLONG diff = ulDeadline.QuadPart - ulNow.QuadPart;
    diff /= 10000000LL; // Convert to seconds

    std::wstring timeRemaining;
    if (diff <= 0)
    {
        timeRemaining = L"Час вийшов";
    }
    else
    {
        int days = diff / 86400;
        int hours = (diff % 86400) / 3600;
        int minutes = (diff % 3600) / 60;

        if (days > 0)
        {
            timeRemaining = std::to_wstring(days) + L" днів " +
                std::to_wstring(hours) + L" год";
        }
        else if (hours > 0)
        {
            timeRemaining = std::to_wstring(hours) + L" год " +
                std::to_wstring(minutes) + L" хв";
        }
        else
        {
            timeRemaining = std::to_wstring(minutes) + L" хв";
        }
    }

    SendMessage(hStatusBar, SB_SETTEXT, 2, (LPARAM)timeRemaining.c_str());
}

void EventDetailsDialog::CopyDetailsToClipboard(HWND hDlg, const Event* event)
{
    if (OpenClipboard(hDlg))
    {
        EmptyClipboard();

        std::wstring details = L"Подія: " + event->name + L"\r\n";
        details += L"Опис: " + event->description + L"\r\n";
        details += FormatEventDetails(event);

        HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, (details.size() + 1) * sizeof(wchar_t));
        if (hMem)
        {
            wchar_t* pMem = (wchar_t*)GlobalLock(hMem);
            wcscpy_s(pMem, details.size() + 1, details.c_str());
            GlobalUnlock(hMem);

            SetClipboardData(CF_UNICODETEXT, hMem);
        }

        CloseClipboard();

        // Show feedback
        HWND hStatusBar = GetDlgItem(hDlg, IDC_EVENT_INFO_STATUS);
        SendMessage(hStatusBar, SB_SETTEXT, 0, (LPARAM)L"Деталі скопійовано в буфер обміну");
    }
}

std::wstring EventDetailsDialog::FormatEventDetails(const Event* event)
{
    std::wstringstream details;

    // Header
    details << L"════════════════════════════════════════\n";

    // Status with emoji and color coding
    details << L"🔄 Статус: ";
    if (event->isCompleted)
    {
        details << L"✅ Виконано";
    }
    else if (event->isPastDeadline)
    {
        details << L"❌ Не виконано (прострочено)";
    }
    else
    {
        details << L"🟢 Виконується";
    }
    details << L"\n\n";

    // Priority with colored indicator
    details << L"⚡ Пріоритет: " << GetPriorityString(event->priority) << L"\n\n";

    // Dates section
    details << L"📅 Дати:\n";
    details << L"   Створено: " << SystemTimeToString(event->creationDate) << L"\n";
    details << L"   Дедлайн:  " << SystemTimeToString(event->deadline) << L"\n\n";

    // Category
    details << L"📁 Категорія: " << event->category << L"\n\n";

    // Recurrence
    if (event->isRecurring)
    {
        details << L"🔁 Повторення: "
            << GetRecurrenceString(event->recurrenceInterval, event->customRecurrenceDays)
            << L"\n\n";
    }

    // Notes if available
    if (!event->notes.empty())
    {
        details << L"📝 Нотатки:\n" << event->notes << L"\n";
    }

    return details.str();
}

std::wstring EventDetailsDialog::GetPriorityString(EventPriority priority)
{
    switch (priority)
    {
    case EventPriority::Critical: return L"🔴 Критичний";
    case EventPriority::High:     return L"🔴 Високий";
    case EventPriority::Medium:   return L"🔴 Середній";
    case EventPriority::Low:      return L"⚪ Низький";
    default:                      return L"⚪ Не вказано";
    }
}

std::wstring EventDetailsDialog::GetRecurrenceString(RecurrenceInterval interval, int customDays)
{
    switch (interval)
    {
    case RecurrenceInterval::Daily:   return L"🔁 Щоденно";
    case RecurrenceInterval::Weekly:  return L"🔁 Щотижня";
    case RecurrenceInterval::Monthly: return L"🔁 Щомісяця";
    case RecurrenceInterval::Yearly:  return L"🔁 Щороку";
    case RecurrenceInterval::Custom:  return L"🔁 Кожні " + std::to_wstring(customDays) + L" днів";
    default:                          return L"🚫 Без повторень";
    }
}

EventDetailsDialog.h:

#pragma once

#define UNICODE
#define _UNICODE

// Color definitions
#define COLOR_PRIORITY_CRITICAL      0x000000FF  // Red
#define COLOR_PRIORITY_HIGH          0x000080FF  // Orange
#define COLOR_PRIORITY_MEDIUM        0x0000FFFF  // Yellow
#define COLOR_PRIORITY_LOW           0x0000FF00  // Green
#define COLOR_PRIORITY_NONE          0x00C0C0C0  // Gray

#define COLOR_COMPLETED             0x0000FF00 
#define COLOR_OVERDUE               0x000000FF  
#define COLOR_IN_PROGRESS           0x08a8ff 

#include <Windows.h>
#include <string>
#include "Event.h"

class EventDetailsDialog
{
public:
    static const int LABEL_FONT_SIZE;
    static const int LABEL_FONT_WEIGHT;
    static const wchar_t* LABEL_FONT_FAMILY;
    static const Event* currentEvent;

    static void Show(HWND hParent, const Event* event);

private:
    static INT_PTR CALLBACK DialogProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static void OnInitDialog(HWND hDlg, const Event* event);
    static std::wstring FormatEventDetails(const Event* event);
    static std::wstring GetPriorityString(EventPriority priority);
    static std::wstring GetRecurrenceString(RecurrenceInterval interval, int customDays);
    static COLORREF GetPriorityColor(EventPriority priority);
    static std::wstring GetStatusString(const Event* event);
    static void SetPriorityIndicatorColor(HWND hDlg, EventPriority priority);
    static void SetStatusIndicatorColor(HWND hDlg, const Event* event);
    static void UpdateTimeRemaining(HWND hDlg, const Event* event);
    static void UpdateStatusBar(HWND hStatusBar, const Event* event);
    static void CopyDetailsToClipboard(HWND hDlg, const Event* event);

};

CategoryComboBox.cpp:

#include "CategoryComboBox.h"
#include <string>

HWND CategoryComboBox::Create(HWND parentHwnd, int x, int y, int width, int height, int controlId)
{
    // Create label
    CreateWindowW(
        L"STATIC",
        L"Категорія:",
        WS_CHILD | WS_VISIBLE | SS_RIGHT,
        x - 130, y, 120, 25,
        parentHwnd,
        NULL, NULL, NULL
    );

    // Create combobox
    HWND hCombo = CreateWindowW(
        L"COMBOBOX",
        L"",
        WS_CHILD | WS_VISIBLE | WS_BORDER | CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_VSCROLL,
        x, y, width, 200,
        parentHwnd,
        (HMENU)controlId,
        NULL,
        NULL
    );

    // Initial population
    UpdateCategories(hCombo);

    return hCombo;
}

void CategoryComboBox::UpdateCategories(HWND comboBox)
{
    if (!comboBox) return;

    // Clear existing items
    SendMessageW(comboBox, CB_RESETCONTENT, 0, 0);

    // Add "All Categories" option
    SendMessageW(comboBox, CB_ADDSTRING, 0, (LPARAM)L"Всі категорії");

    // Load categories from AppConfig
    for (int i = 0; i < AppConfig::GetCategoryCount(); i++)
    {
        const WCHAR* category = AppConfig::GetCategory(i);
        SendMessageW(comboBox, CB_ADDSTRING, 0, (LPARAM)category);
    }

    // Select "All Categories" by default
    SendMessageW(comboBox, CB_SETCURSEL, 0, 0);
}

int CategoryComboBox::GetSelectedCategoryIndex(HWND comboBox)
{
    return (int)SendMessageW(comboBox, CB_GETCURSEL, 0, 0);
}

std::wstring CategoryComboBox::GetSelectedCategory(HWND comboBox)
{
    int index = GetSelectedCategoryIndex(comboBox);
    if (index <= 0) return L""; // "All Categories" or no selection

    WCHAR buffer[256] = L"\0";
    SendMessageW(comboBox, CB_GETLBTEXT, index, (LPARAM)buffer);
    return std::wstring(buffer);
}

CategoryComboBox.h:
#pragma once
#include <Windows.h>
#include "AppConfig.h"

class CategoryComboBox
{
public:
    static HWND Create(HWND parentHwnd, int x, int y, int width, int height, int controlId);
    static void UpdateCategories(HWND comboBox);
    static int GetSelectedCategoryIndex(HWND comboBox);
    static std::wstring GetSelectedCategory(HWND comboBox);
};

DefaultAppConfig.cpp:
#include "DefaultAppConfig.h"

const WCHAR* DEFAULT_CATEGORIES[] =
{
	L"Загальні",
	L"Робота",
	L"Особисті",
	L"Сім'я"
};

const std::wstring AboutAppMessage =	L"Менеджер подій\n"
										L"Версія 1.0\n\n"

										L"Автор: Яковенко Нікіта Едуардович\n"
										L"Контакти: nikita.iakovenko@nure.ua\n\n"

										L"Опис програми:\n"
										L"Комплексна система керування подіями, яка допомагає відстежувати"
										L"завдання, дедлайни та повторювані події з розумними сповіщеннями.\n\n"

										L"Основні функції:\n"
										L"✓ Керування подіями з майбутніми датами\n"
										L"✓ Розумне відстеження дедлайнів та сповіщення\n"
										L"✓ Підтримка повторюваних подій (щоденно/щотижня/щомісяця)\n"
										L"✓ Відстеження виконання завдань\n"
										L"✓ Потужний пошук та фільтрація\n"
										L"✓ Метрики продуктивності та статистика\n"
										L"✓ Можливість збереження даних\n"
										L"✓ Налаштовувані категорії та пріоритети\n\n"

										L"Технічні деталі:\n"
										L"- Реалізовано на Win32 API\n"
										L"- Базовий функціонал без зовнішніх залежностей\n"
										L"- Видалення створених категорій відбувається через\n"
										L"  файл конфігурації в директорії застосунку.";

const int DEFAULT_CATEGORY_COUNT = sizeof(DEFAULT_CATEGORIES) / sizeof(DEFAULT_CATEGORIES[0]);

const int DEFAULT_BUTTON_WIDTH = 165;
const int DEFAULT_BUTTON_HEIGHT = 35;

DefaultAppConfig.h:

#pragma once

#include "Windows.h"
#include <string>

#define MAX_EVENTS 1000
#define MAX_EVENT_CATEGORIES 100

#define MAX_EVENT_CATEGORY_LENGTH 32
#define MAX_EVENT_NAME_LENGTH 24
#define MAX_EVENT_DESC_LENGTH 1024
#define MAX_EVENT_NOTES_LENGTH 256
#define MAX_AUTO_UPDATE_INTERVAL_SEC 86400
#define DEFAULT_AUTO_UPDATE_INTERVAL_SEC 5

#define MAX_SEARCH_INPUT_LENGTH MAX_EVENT_NAME_LENGTH

// Colors 

#define EVENT_PRIORITY_CRITICAL_COLOR		RGB(255, 140, 0)
#define EVENT_PRIORITY_HIGH_COLOR			RGB(255, 255, 0)
#define EVENT_PRIORITY_MEDIUM_COLOR			RGB(255, 255, 204)
#define EVENT_PRIORITY_LOW_COLOR			RGB(204, 209, 184)
#define EVENT_DONE_COLOR					RGB(187, 224, 182)
#define EVENT_PASTDUE_COLOR					RGB(230, 161, 161)


extern const std::wstring AboutAppMessage;

// Default categories to use if loading from file fails
extern const WCHAR* DEFAULT_CATEGORIES[];
extern const int DEFAULT_CATEGORY_COUNT;

// Styles 

extern const int DEFAULT_BUTTON_WIDTH;
extern const int DEFAULT_BUTTON_HEIGHT;

AppConfig.cpp:
#include "AppConfig.h"
#include "Utilities.h"

// Initialize static variables
WCHAR** AppConfig::categories = nullptr;
int AppConfig::categoryCount = 0;
int AppConfig::maxCategories = 0;

// Load configuration from a file
BOOL AppConfig::LoadConfig()
{
    std::wstring configPath = GetExecutableFolderPath() + L"\\app_config.txt";

    // Open the file with UTF-8 encoding
    std::wifstream configFile(configPath);

    if (!configFile.is_open())
    {
        // Failed to open file, use default categories
        categoryCount = 0;
        return FALSE;
    }

    // Set the locale to support UTF-8 encoded files
    configFile.imbue(std::locale(configFile.getloc(), new std::codecvt_utf8<wchar_t>));

    std::wstring line;
    categoryCount = 0;

    // Process the file line by line
    while (std::getline(configFile, line))
    {
        // Trim any extra whitespace from the line
        line.erase(std::remove(line.begin(), line.end(), L'\n'), line.end());
        line.erase(std::remove(line.begin(), line.end(), L'\r'), line.end());

        // Skip empty lines or comment lines (lines starting with "//")
        if (line.empty() || line.find(L"//") == 0)
            continue;

        // Handle the [Categories] section
        if (line.find(L"[Categories]") == 0)
        {
            // Read categories after the [Categories] header
            while (std::getline(configFile, line))
            {
                // Trim whitespace
                line.erase(std::remove(line.begin(), line.end(), L'\n'), line.end());
                line.erase(std::remove(line.begin(), line.end(), L'\r'), line.end());

                // Stop reading categories if we hit another section (e.g., [GeneralSettings])
                if (line.find(L"[") == 0)
                    break;

                // Each line should have the format "categoryN = categoryName"
                size_t eqPos = line.find(L"=");
                if (eqPos != std::wstring::npos)
                {
                    // Extract the category name after the "=" sign and trim spaces
                    std::wstring categoryName = line.substr(eqPos + 1);
                    categoryName.erase(std::remove(categoryName.begin(), categoryName.end(), L' '), categoryName.end());
                    categoryName.erase(std::remove(categoryName.begin(), categoryName.end(), L'\t'), categoryName.end());

                    // Add the category to the list if it�s not empty
                    if (!categoryName.empty() && categoryCount < MAX_EVENT_CATEGORIES)
                    {
                        AddCategory(categoryName.c_str());
                    }
                }
            }
        }
    }

    configFile.close();
    return TRUE;
}

// Save configuration to a file
BOOL AppConfig::SaveConfig()
{
    std::wstring configPath = GetExecutableFolderPath() + L"\\app_config.txt";

    // Open the file with UTF-8 encoding for writing (this will overwrite the file)
    std::wofstream configFile(configPath);
    if (!configFile.is_open())
    {
        return FALSE;
    }

    // Set the locale to support UTF-8 encoded files
    configFile.imbue(std::locale(configFile.getloc(), new std::codecvt_utf8<wchar_t>()));

    // Start by writing a header with comments about the config file
    configFile << L"// Application Configuration File\n";
    configFile << L"// This file contains categories and other settings for the application.\n";
    configFile << L"// You can edit these values, but please ensure the format is preserved.\n\n";

    // Write categories section with a comment
    configFile << L"[Categories]\n";
    for (int i = 0; i < categoryCount; i++)
    {
        configFile << L"category" << (i + 1) << L" = " << categories[i] << L"\n";
    }

    // If no categories are present, write a default message
    if (categoryCount == 0)
    {
        configFile << L"// No categories found. Please add some categories.\n";
    }

    // Close the file after writing the content
    configFile.close();
    return TRUE;
}


// Get category by index
const WCHAR* AppConfig::GetCategory(int index)
{
    if (index >= 0 && index < categoryCount)
    {
        return categories[index];
    }
    return L""; // Return empty string if invalid index
}

// Get the total count of categories
int AppConfig::GetCategoryCount()
{
    return categoryCount;
}

// Add category dynamically
BOOL AppConfig::AddCategory(const WCHAR* newCategory)
{
    // Trim leading and trailing whitespace from the category
    std::wstring trimmedCategory(newCategory);
    TrimString(trimmedCategory);

    // If the trimmed category is empty, return false
    if (trimmedCategory.empty())
    {
        return FALSE;
    }

    // Check for maximum category length
    if (wcslen(newCategory) >= MAX_EVENT_CATEGORY_LENGTH)
    {
        // If the category name exceeds the maximum length, return false
        return FALSE;
    }

    // Check if the category already exists
    for (int i = 0; i < categoryCount; i++)
    {
        if (wcscmp(categories[i], newCategory) == 0)
        {
            // Category already exists, so return false
            return FALSE;
        }
    }

    // Resize if needed
    if (categoryCount >= maxCategories)
    {
        ResizeCategoryArray();
    }

    // Copy the new category into the array
    size_t len = wcslen(newCategory) + 1; // Include the null terminator
    categories[categoryCount] = new WCHAR[len];
    wcscpy_s(categories[categoryCount], len, newCategory);

    categoryCount++;
    return TRUE; // Successfully added the category
}



// Resize the categories array when the number of categories exceeds the current size
void AppConfig::ResizeCategoryArray()
{
    // If it's the first allocation
    if (categories == nullptr)
    {
        maxCategories = 10; // Start with a smaller number
        categories = new WCHAR * [maxCategories];
    }
    else
    {
        // Double the array size when resizing
        maxCategories *= 2;
        WCHAR** newCategories = new WCHAR * [maxCategories];

        // Copy existing categories to the new array
        for (int i = 0; i < categoryCount; i++)
        {
            newCategories[i] = categories[i];
        }

        // Delete old array and update pointer
        delete[] categories;
        categories = newCategories;
    }
}

AppConfig.h:
#pragma once

#include "Windows.h"
#include <string>
#include "DefaultAppConfig.h"
#include <fstream>
#include <codecvt>

class AppConfig
{
public:
	static BOOL LoadConfig(); // Loads the configuration from file
	static BOOL SaveConfig(); // Saves the configuration to file
	static const WCHAR* GetCategory(int index);
	static int GetCategoryCount();
	static BOOL AddCategory(const WCHAR* newCategory);

private:
	static WCHAR** categories;
	static int categoryCount;
	static int maxCategories;

	static void ResizeCategoryArray();
};

EventList.h:
#pragma once

#include "Windows.h"
#include <windowsx.h>
#include "Utilities.h"
#include "AppState.h"

class EventList
{
public:
	// Custom drawing constants
	static const int EVENT_ITEM_HEIGHT = 90;
	static const int EVENT_ITEM_MARGIN = 5;
	static const int EVENT_ITEM_PADDING = 10;


	static void Initialize(HWND* parentWnd);

	// Custom window procedure for our event list
	static LRESULT CALLBACK EventListWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

	static void DrawEventItem(HDC hdc, const RECT* rcItem, const Event* event, BOOL isSelected);
	static void DrawEventBackground(HDC hdc, const RECT* rcItem, const Event* event, BOOL isSelected);
	static COLORREF GetEventBackgroundColor(const Event* event, BOOL isSelected);
	static COLORREF GetEventTextColor(const Event* event, BOOL isSelected);
	static void DrawEventHeader(HDC hdc, RECT* rcText, const Event* event, BOOL isSelected);
	static void DrawEventDescription(HDC hdc, RECT* rcText, const Event* event);
	static void DrawEventStatusAndCategory(HDC hdc, RECT* rcText, const Event* event);


	static void SetEventsList(Event* eventsList, int eventsCount);
	static void HandleEventListItemClick(LPARAM& lParam, HWND hWnd);
	static void PaintEventListView(HWND hWnd);
	static bool TryGetSelectedEventFromList(Event*& targetEvent);
	static int CurrentSelectedEventIndex();

	static void Update();
	static void Redraw();


private:
	static HWND parentWnd;
	static HWND hEventList;
	static Event* eventsArray;
	static int eventsCount;
	static int selectedEventIndex;
};

Event.cpp:
#include "Event.h"
#include <windows.h>
#include <string>
#include <ctime>
#include "Utilities.h"

Event::Event() :
    name(L""),
    description(L""),
    notes(L""),
    category(L"General"),
    isCompleted(false),
    isPastDeadline(false),
    priority(EventPriority::Medium),
    isRecurring(false),
    recurrenceInterval(RecurrenceInterval::None),
    customRecurrenceDays(0),
    isReccurenceHandled(false),
    notificationStates{ NOTIFICATION_NONE, NOTIFICATION_NONE, NOTIFICATION_NONE }
{
    // Initialize creation date to current time
    GetLocalTime(&creationDate);

    // Initialize deadline to same as creation date initially
    deadline = creationDate;

    // Initialize GUID with a new unique value
    CoCreateGuid(&uniqueID);
}

void Event::UpdateStatus()
{
    isPastDeadline = IsSystemTimeInPast(deadline);
}

std::wstring Event::GetStatusString() const
{
    if (isCompleted) return L"Виконано";
    if (isPastDeadline) return L"Не виконано";
    return L"Виконується";
}

bool Event::ShouldNotify(NotificationType type) const
{
    if (isCompleted || isPastDeadline)
        return false;

    return notificationStates[type] == NOTIFICATION_NONE;
}

void Event::MarkNotified(NotificationType type)
{
    notificationStates[type] = NOTIFICATION_SENT;
}

void Event::ResetNotificationStates()
{
    for (int i = 0; i < NOTIFICATION_COUNT; i++)
    {
        notificationStates[i] = NOTIFICATION_NONE;
    }
}

Event.h:
#pragma once
#include <windows.h>
#include <string>

enum EventPriority
{
    Low = 0,
    Medium = 1,
    High = 2,
    Critical = 3
};

enum RecurrenceInterval
{
    None = 0,
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
    Yearly = 4,
    Custom = 5
};

enum NotificationState
{
    NOTIFICATION_NONE = 0,      // No notification sent
    NOTIFICATION_SENT           // Notification was sent
};

enum NotificationType
{
    NOTIFICATION_24H = 0,
    NOTIFICATION_12H = 1,
    NOTIFICATION_1H = 2,
    NOTIFICATION_COUNT
};

struct Event
{
    std::wstring name;
    std::wstring description;
    std::wstring notes;
    std::wstring category;
    SYSTEMTIME creationDate;
    SYSTEMTIME deadline;
    bool isCompleted;
    bool isPastDeadline;
    EventPriority priority;

    // Recurrence settings
    bool isRecurring;
    RecurrenceInterval recurrenceInterval;
    bool isReccurenceHandled;
    int customRecurrenceDays;
    NotificationState notificationStates[NOTIFICATION_COUNT];

    // Unique identifier
    GUID uniqueID;

    Event();
    void UpdateStatus();
    std::wstring GetStatusString() const;
    bool ShouldNotify(NotificationType type) const;
    void MarkNotified(NotificationType type);
    void ResetNotificationStates();
};
